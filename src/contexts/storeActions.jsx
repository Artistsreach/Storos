import React from 'react';
import { 
    fetchPexelsImages as utilFetchPexelsImages, 
    generateId as utilGenerateId, 
    generateAIProductDescriptions, 
    generateAIStoreContent,
    fetchPexelsVideos // Import the new video fetching utility
} from '@/lib/utils';
// import { overlayLogoOnProductImage } from '@/lib/imageUtils'; // Will be replaced by generateProductWithGemini
import { generateLogoWithGemini } from '@/lib/geminiImageGeneration';
import { generateProductWithGemini } from '@/lib/geminiProductGeneration';
import { generateCollectionWithGemini } from '@/lib/geminiCollectionGeneration'; // Import for AI collection generation
import { generateStoreNameSuggestions } from '@/lib/gemini'; // Import for AI store name generation
import { 
    fetchShopifyStorefrontAPI, 
    GET_SHOP_METADATA_QUERY, 
    GET_PRODUCTS_QUERY,
    GET_COLLECTIONS_QUERY, // Added
    GET_LOCALIZATION_INFO_QUERY // Added
} from '@/lib/shopify';

const getRandomColor = () => ['#3B82F6', '#8B5CF6', '#EC4899', '#10B981', '#F59E0B', '#EF4444', '#6366F1', '#14B8A6', '#F97316'][Math.floor(Math.random() * 9)];
const getRandomFont = () => ['Inter', 'Roboto', 'Poppins', 'Montserrat', 'Open Sans'][Math.floor(Math.random() * 5)];
const getRandomLayout = () => ['grid', 'list'][Math.floor(Math.random() * 2)];


export const generateAIProductsData = async (type, count, storeName, storeLogoDataUrl, { fetchPexelsImages = utilFetchPexelsImages, generateId = utilGenerateId } = {}) => {
    const products = [];
    const priceRanges = { fashion: {min:20,max:200}, electronics: {min:50,max:1300}, food: {min:5,max:50}, jewelry: {min:100,max:1000}, general: {min:10,max:300} };
    const range = priceRanges[type] || priceRanges.general;
    const productNamesPool = {
      fashion: ['Classic Tee', 'Urban Jeans', 'Silk Scarf', 'Leather Boots', 'Summer Dress', 'Knit Sweater'],
      electronics: ['HD Webcam', 'Noise-Cancelling Buds', 'Smart Display', 'Gaming Pad', 'Portable Drive', 'VR Headset'],
      food: ['Artisan Bread', 'Gourmet Cheese', 'Organic Berries', 'Craft Coffee', 'Spiced Nuts', 'Dark Chocolate Bar'],
      jewelry: ['Pearl Necklace', 'Sapphire Ring', 'Gold Hoops', 'Charm Bracelet', 'Silver Cufflinks', 'Diamond Studs'],
      general: ['Utility Tool', 'Desk Organizer', 'Travel Mug', 'Yoga Mat', 'Scented Candle', 'Board Game']
    };
    const names = productNamesPool[type] || productNamesPool.general;
    const selectedNames = [...names].sort(() => 0.5 - Math.random()).slice(0, count);

    const imageQueries = selectedNames.map(name => `${type} ${name} product shot`);
    const productImages = await fetchPexelsImages(imageQueries.join(';'), count, 'square');

    for (let i = 0; i < count; i++) {
      const name = selectedNames[i];
      const pexelsImageObject = productImages[i];
      let finalProductImageUrl;

      if (pexelsImageObject && pexelsImageObject.src && pexelsImageObject.src.medium && storeLogoDataUrl) {
        try {
          console.log(`[generateAIProductsData] Overlaying logo on Pexels image: ${pexelsImageObject.src.medium}`);
          finalProductImageUrl = await overlayLogoOnProductImage(pexelsImageObject.src.medium, storeLogoDataUrl);
        } catch (e) {
          console.error(`[generateAIProductsData] Failed to overlay logo on ${pexelsImageObject.src.medium}, using original.`, e);
          finalProductImageUrl = pexelsImageObject.src.medium;
        }
      } else if (pexelsImageObject && pexelsImageObject.src && pexelsImageObject.src.medium) {
        finalProductImageUrl = pexelsImageObject.src.medium;
      } else {
        finalProductImageUrl = `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(name)}`;
      }
      
      products.push({
        id: `product-ai-${generateId()}`,
        name,
        price: parseFloat((Math.random() * (range.max - range.min) + range.min).toFixed(2)),
        description: generateAIProductDescriptions(type, name),
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 80) + 20,
        image: { 
          id: (pexelsImageObject && pexelsImageObject.id) || generateId(), 
          src: { medium: finalProductImageUrl }, 
          alt: (pexelsImageObject && pexelsImageObject.alt) || `Product image for ${name}` 
        },
        // logoUrl: storeLogoDataUrl, // No longer needed per product if image has logo
        storeName: storeName,
      });
    }
    return products;
};


export const generateStoreFromWizardData = async (wizardData, { fetchPexelsImages = utilFetchPexelsImages, generateId = utilGenerateId } = {}) => {
    const storeId = `store-wizard-${generateId()}`;
    const { productType, storeName, logoUrl, products: wizardProducts, prompt } = wizardData;

    let finalProducts = [];
    if (wizardProducts.source === 'ai') {
      // AI products are generated by generateProductWithGemini, which now handles logo inclusion.
      // item.imageUrl from wizardData.products.items should be the final image.
      finalProducts = wizardProducts.items.map(item => ({
        id: `product-ai-${generateId()}`,
        name: item.name,
        price: parseFloat(item.price), // Ensure price is a number
        description: item.description,
        image: { 
          id: generateId(), 
          src: { medium: item.imageUrl }, // item.imageUrl is from generateProductWithGemini, should have logo
          alt: item.name,
        },
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 80) + 20,
      }));
    } else if (wizardProducts.source === 'manual') {
      // For manual products, use the provided details.
      // If imageUrl is provided (e.g., user pasted a URL), use it. Otherwise, placeholder.
      // DO NOT use Pexels for manual product images as per user feedback.
      finalProducts = wizardProducts.items.map(p => ({
        id: `product-manual-${generateId()}`,
        name: p.name,
        price: parseFloat(p.price),
        description: p.description || generateAIProductDescriptions(productType, p.name), // Fallback description
        image: {
          id: generateId(),
          src: { medium: p.imageUrl || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.name)}` },
          alt: p.name,
        },
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 50) + 20,
      }));
    }
    
    const heroImages = await fetchPexelsImages(`${productType} store hero ${prompt}`, 1, 'landscape');
  const heroVideos = await fetchPexelsVideos(`${productType} store ambiance ${prompt}`, 1, 'landscape');
  const aiContent = generateAIStoreContent(productType, storeName);
    const cardBgImages = await fetchPexelsImages(`${productType} abstract background`, 1, 'landscape');
    const cardBackgroundUrl = cardBgImages[0]?.src?.large || cardBgImages[0]?.src?.original || '';
    const templateVersion = 'v1'; // Default to classic template


    return {
      id: storeId,
      name: storeName,
      template_version: templateVersion, // Ensure this is 'v1'
      type: productType,
      description: aiContent.heroDescription,
      prompt: prompt || `A ${productType} store called ${storeName}`,
      products: finalProducts,
      collections: wizardData.collections.items.map(collection => ({ // Ensure collections are passed through
        id: `collection-wizard-${generateId()}`, // Generate a temporary ID if needed
        name: collection.name,
        description: collection.description,
        imageUrl: collection.imageUrl,
        product_ids: collection.product_ids || [], // Ensure product_ids are carried over
      })),
      hero_image: heroImages[0] || { src: { large: 'https://via.placeholder.com/1200x800.png?text=Hero+Image' }, alt: 'Placeholder Hero Image' },
      hero_video_url: heroVideos[0]?.url || null,
      hero_video_poster_url: heroVideos[0]?.image || null,
      logo_url: logoUrl || `https://via.placeholder.com/100x100.png?text=${storeName.substring(0,1)}`,
      theme: {
        primaryColor: getRandomColor(),
        secondaryColor: getRandomColor(),
        fontFamily: getRandomFont(),
        layout: getRandomLayout(),
      },
      content: aiContent,
      data_source: 'wizard',
      card_background_url: cardBackgroundUrl,
    };
};

export const generateStoreFromPromptData = async (
  prompt,
  {
    storeNameOverride = null,
    productTypeOverride = null,
    // storeLogoDataUrl is no longer needed as an option, it will be generated
    fetchPexelsImages = utilFetchPexelsImages,
    generateId = utilGenerateId,
  } = {}
) => {
  const storeId = `store-ai-${generateId()}`;
  const keywords = prompt.toLowerCase().split(' ');

  let storeType = productTypeOverride || 'general';
  if (!productTypeOverride) {
    if (keywords.some(word => ['clothing', 'fashion', 'apparel', 'wear'].includes(word))) storeType = 'fashion';
    else if (keywords.some(word => ['tech', 'electronics', 'gadget', 'digital'].includes(word))) storeType = 'electronics';
    else if (keywords.some(word => ['food', 'grocery', 'meal', 'organic'].includes(word))) storeType = 'food';
    else if (keywords.some(word => ['jewelry', 'accessory', 'watch', 'luxury'].includes(word))) storeType = 'jewelry';
  }

  let brandName = storeNameOverride;

  if (!brandName) { // If storeNameOverride was not provided, attempt AI generation
    try {
      console.log(`[generateStoreFromPromptData] No storeNameOverride. Attempting AI name generation using prompt: "${prompt}"`);
      const nameSuggestionsResult = await generateStoreNameSuggestions(prompt); // Pass the full prompt for context
      if (nameSuggestionsResult && nameSuggestionsResult.suggestions && nameSuggestionsResult.suggestions.length > 0) {
        brandName = nameSuggestionsResult.suggestions[0]; // Take the first suggestion
        console.log(`[generateStoreFromPromptData] AI generated store name: ${brandName}`);
      } else {
        console.warn("[generateStoreFromPromptData] AI name generation yielded no suggestions. Falling back to heuristic.");
        const brandWordsHeuristic = prompt.split(' ').filter(word => word.charAt(0) === word.charAt(0).toUpperCase() && word.length > 2);
        brandName = brandWordsHeuristic[0]; // Fallback 1: First capitalized word
      }
    } catch (error) {
      console.error("[generateStoreFromPromptData] Error during AI store name generation:", error);
      // Fallback to heuristic on error
      const brandWordsHeuristic = prompt.split(' ').filter(word => word.charAt(0) === word.charAt(0).toUpperCase() && word.length > 2);
      brandName = brandWordsHeuristic[0]; // Fallback 1: First capitalized word
    }
  }
  
  // Final fallback if brandName is still not set (e.g., override was null, AI failed, and heuristic found no capitalized word)
  if (!brandName) {
    brandName = `${storeType.charAt(0).toUpperCase() + storeType.slice(1)} Emporium ${generateId().substring(0,4)}`;
    console.log(`[generateStoreFromPromptData] Using final fallback store name: ${brandName}`);
  }
  
  // Ensure brandName is not too long
  if (brandName.length > 50) brandName = brandName.substring(0, 50);


  // 1. Generate Logo
  let logoImageBase64 = null;
  let actualLogoUrl = `https://via.placeholder.com/100x100.png?text=${brandName.substring(0, 1)}`; // Default placeholder
  try {
    console.log(`[generateStoreFromPromptData] Generating logo for: ${brandName}`);
    const logoGenResult = await generateLogoWithGemini(brandName);
    if (logoGenResult && logoGenResult.imageData) {
      logoImageBase64 = logoGenResult.imageData;
      actualLogoUrl = `data:image/png;base64,${logoImageBase64}`;
      console.log(`[generateStoreFromPromptData] Logo generated successfully for ${brandName}.`);
    } else {
      console.warn(`[generateStoreFromPromptData] Logo generation did not return image data for ${brandName}. Text response: ${logoGenResult?.textResponse}`);
    }
  } catch (error) {
    console.error(`[generateStoreFromPromptData] Error generating logo for ${brandName}:`, error);
    // actualLogoUrl remains the placeholder
  }

  // 2. Generate Products using generateProductWithGemini
  const generatedProducts = [];
  const generatedProductTitles = []; // To track titles for uniqueness
  const numProductsToGenerate = 6;
  const maxTotalAttempts = numProductsToGenerate * 2; // Safety break for the while loop
  let currentAttempts = 0;

  console.log(`[generateStoreFromPromptData] Attempting to generate ${numProductsToGenerate} unique products for ${brandName} (type: ${storeType}).`);

  while (generatedProducts.length < numProductsToGenerate && currentAttempts < maxTotalAttempts) {
    currentAttempts++;
    try {
      console.log(`[generateStoreFromPromptData] Generating product attempt ${currentAttempts} (aiming for ${generatedProducts.length + 1}/${numProductsToGenerate} unique products)... Excluding titles: ${generatedProductTitles.join(', ')}`);
      
      const singleProductData = await generateProductWithGemini(
        storeType, 
        brandName, 
        logoImageBase64, 
        'image/png',
        generatedProductTitles // Pass existing titles to encourage uniqueness
      );
      
      if (singleProductData && singleProductData.imageData && singleProductData.title && singleProductData.price && singleProductData.description) {
        const normalizedTitle = singleProductData.title.toLowerCase().trim();
        if (!generatedProductTitles.includes(normalizedTitle)) {
          generatedProducts.push({
            id: `product-gemini-${generateId()}`,
            name: singleProductData.title,
            price: parseFloat(singleProductData.price) || 0,
            description: singleProductData.description,
            image: {
              id: generateId(),
              src: { medium: `data:image/png;base64,${singleProductData.imageData}` }, // Assuming PNG
              alt: singleProductData.title,
            },
            rating: (Math.random() * 1.5 + 3.5).toFixed(1),
            stock: Math.floor(Math.random() * 80) + 20,
          });
          generatedProductTitles.push(normalizedTitle);
          console.log(`[generateStoreFromPromptData] Product "${singleProductData.title}" generated successfully and is unique. (${generatedProducts.length}/${numProductsToGenerate})`);
        } else {
          console.warn(`[generateStoreFromPromptData] Duplicate product title generated and skipped: "${singleProductData.title}". Attempt ${currentAttempts}/${maxTotalAttempts}.`);
        }
      } else {
        console.warn(`[generateStoreFromPromptData] Failed to generate complete data for product attempt ${currentAttempts}. Data:`, singleProductData);
      }
    } catch (error) {
      console.error(`[generateStoreFromPromptData] Error during product generation attempt ${currentAttempts}:`, error);
      // Continue to next attempt if not maxed out
    }
  }

  if (generatedProducts.length < numProductsToGenerate) {
    console.warn(`[generateStoreFromPromptData] Could only generate ${generatedProducts.length} unique products after ${maxTotalAttempts} total attempts.`);
  }
  // Removed placeholder generation block to align with wizard behavior.
  // If all product generations fail, generatedProducts will be an empty array.
  if (generatedProducts.length === 0 && numProductsToGenerate > 0) {
    console.warn(`[generateStoreFromPromptData] No products were generated successfully. The store will be created with an empty product list.`);
  }

  const heroImages = await fetchPexelsImages(`${storeType} ${brandName} hero ${prompt}`, 1, 'landscape');
  const heroVideos = await fetchPexelsVideos(`${storeType} ${brandName} ambiance ${prompt}`, 1, 'landscape');
  const aiContent = generateAIStoreContent(storeType, brandName);
  const cardBgImagesPrompt = await fetchPexelsImages(`${storeType} store background`, 1, 'landscape');
  const cardBackgroundUrlPrompt = cardBgImagesPrompt[0]?.src?.large || cardBgImagesPrompt[0]?.src?.original || '';
  const templateVersion = 'v1'; // Default to classic template

  // 3. Generate Collections
  const generatedCollections = [];
  const numCollectionsToGenerate = 3; // Or make this dynamic
  const existingCollectionNamesForPrompt = [];

  if (generatedProducts.length > 0) { // Only generate collections if there are products
    console.log(`[generateStoreFromPromptData] Attempting to generate ${numCollectionsToGenerate} collections for ${brandName}.`);
    for (let i = 0; i < numCollectionsToGenerate; i++) {
      try {
        console.log(`[generateStoreFromPromptData] Generating collection ${i + 1}/${numCollectionsToGenerate}...`);
        const collectionData = await generateCollectionWithGemini(
          storeType,
          brandName,
          generatedProducts, // Pass the full product objects (which include .id and .name)
          existingCollectionNamesForPrompt
        );

        if (collectionData && !collectionData.error && collectionData.name) {
          let finalCollectionImageUrl = `https://via.placeholder.com/400x200.png?text=${encodeURIComponent(collectionData.name || "Collection")}`;
          if (collectionData.imageData) {
            finalCollectionImageUrl = `data:image/png;base64,${collectionData.imageData}`;
          }
          generatedCollections.push({
            id: `collection-gemini-${generateId()}`, // Temporary ID for the collection itself
            name: collectionData.name,
            description: collectionData.description,
            imageUrl: finalCollectionImageUrl, // Use the data URL or placeholder
            product_ids: collectionData.product_ids || [], // Ensure product_ids is an array
          });
          existingCollectionNamesForPrompt.push(collectionData.name);
          console.log(`[generateStoreFromPromptData] Collection "${collectionData.name}" generated with ${collectionData.product_ids?.length || 0} products.`);
        } else {
          console.warn(`[generateStoreFromPromptData] Failed to generate complete data for collection ${i + 1}. Error: ${collectionData?.error}`);
        }
      } catch (error) {
        console.error(`[generateStoreFromPromptData] Error during collection generation attempt ${i + 1}:`, error);
      }
    }
  } else {
    console.warn(`[generateStoreFromPromptData] Skipping collection generation as no products were generated for ${brandName}.`);
  }


  return {
    id: storeId,
    name: brandName,
    template_version: templateVersion, // Ensure this is 'v1'
    type: storeType,
    description: aiContent.heroDescription,
    prompt,
    products: generatedProducts,
    collections: generatedCollections, // Add generated collections here
    hero_image: heroImages[0] || { src: { large: 'https://via.placeholder.com/1200x800.png?text=Hero+Image' }, alt: 'Placeholder Hero Image' },
    hero_video_url: heroVideos[0]?.url || null,
    hero_video_poster_url: heroVideos[0]?.image || null,
    logo_url: actualLogoUrl, // Use the generated or placeholder logo URL
    theme: {
      primaryColor: getRandomColor(),
      secondaryColor: getRandomColor(),
        fontFamily: getRandomFont(),
        layout: getRandomLayout(),
      },
      content: aiContent,
      data_source: 'ai',
      card_background_url: cardBackgroundUrlPrompt,
    };
};

// New function to fetch only shop metadata for preview
export const fetchShopifyStoreMetadata = async (domain, token) => {
    const shopData = await fetchShopifyStorefrontAPI(domain, token, GET_SHOP_METADATA_QUERY);
    return shopData.shop; // Return raw shop data
};

// New function to fetch collections for preview (with pagination support)
export const fetchShopifyCollectionsList = async (domain, token, first = 10, cursor = null) => {
    const collectionsData = await fetchShopifyStorefrontAPI(domain, token, GET_COLLECTIONS_QUERY, { first, cursor });
    return collectionsData.collections; // Return collections connection object (includes edges and pageInfo)
};

// New function to fetch products for preview (with pagination support)
export const fetchShopifyProductsList = async (domain, token, first = 10, cursor = null) => {
    const productsData = await fetchShopifyStorefrontAPI(domain, token, GET_PRODUCTS_QUERY, { first, cursor });
    return productsData.products; // Return products connection object
};

// New function to fetch localization info
export const fetchShopifyLocalizationInfo = async (domain, token, countryCode = "US", languageCode = "EN") => {
    // Note: The @inContext directive in GET_LOCALIZATION_INFO_QUERY might need to be dynamic
    // For now, it's hardcoded in the query. If dynamic context is needed, the query itself or variables would need adjustment.
    const localizationData = await fetchShopifyStorefrontAPI(domain, token, GET_LOCALIZATION_INFO_QUERY, {
      // Variables for @inContext if the query is parameterized.
      // Example: country: countryCode, language: languageCode 
    });
    return localizationData.localization;
};

// Modified to accept fetched data as parameters and a potential generated logo
export const mapShopifyDataToInternalStore = async (shopifyStore, shopifyProducts, shopifyCollections, domain, { generateId = utilGenerateId } = {}, generatedLogoDataUrl = null) => {
    const mappedProducts = shopifyProducts.map(p => ({
      id: p.id, // Already a GID string
      name: p.title,
      // Use description from guide, not descriptionHtml
      description: p.description ? p.description.substring(0,250) + (p.description.length > 250 ? "..." : "") : 'No description available.',
      // Use priceV2 (aliased as price) from updated GET_PRODUCTS_QUERY
      price: parseFloat(p.variants?.edges[0]?.node.price?.amount || 0),
      currencyCode: p.variants?.edges[0]?.node.price?.currencyCode || 'USD',
      image: {
        id: p.images?.edges[0]?.node.id || generateId(),
        // Ensure URL is correctly accessed
        src: { medium: p.images?.edges[0]?.node.url || p.variants?.edges[0]?.node.image?.url || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.title)}` },
        alt: p.images?.edges[0]?.node.altText || p.variants?.edges[0]?.node.image?.altText || p.title,
      },
      tags: p.tags, // Tags is an array of strings
      availableForSale: p.variants?.edges[0]?.node.availableForSale,
      // Add other fields from GET_PRODUCTS_QUERY if needed for internal store
      rating: (Math.random() * 1.5 + 3.5).toFixed(1), 
      stock: Math.floor(Math.random() * 100) + 10, 
    }));

    // Map collections (basic mapping for now)
    const mappedCollections = shopifyCollections.map(c => ({
        id: c.id,
        title: c.title,
        description: c.description,
        handle: c.handle,
        // Potentially map products within collections if fetched and needed
        productCount: c.products?.edges?.length || 0, 
    }));
    
    // Use updated field names from GET_SHOP_METADATA_QUERY
    const primaryColor = shopifyStore.brand?.colors?.primary?.[0]?.background || getRandomColor();
    const heroImage = {
        id: generateId(),
        src: { large: shopifyStore.brand?.coverImage?.image?.url || `https://via.placeholder.com/1200x800.png?text=${encodeURIComponent(shopifyStore.name)}` },
        alt: shopifyStore.brand?.coverImage?.image?.altText || shopifyStore.name,
    };
    const shopifyProvidedLogo = shopifyStore.brand?.logo?.image?.url || shopifyStore.brand?.squareLogo?.image?.url;
    const logoUrl = generatedLogoDataUrl || shopifyProvidedLogo || `https://via.placeholder.com/100x100.png?text=${shopifyStore.name.substring(0,1)}`;
    const aiContent = generateAIStoreContent('general', shopifyStore.name); // Keep AI content for fallback
    const cardBgImagesShopify = await utilFetchPexelsImages(`${shopifyStore.name} background`, 1, 'landscape');
    const cardBackgroundUrlShopify = cardBgImagesShopify[0]?.src?.large || cardBgImagesShopify[0]?.src?.original || '';

    return {
      id: `store-shopify-${shopifyStore.primaryDomain.host.replace(/\./g, '-')}-${generateId()}`,
      name: shopifyStore.name,
      type: 'shopify-imported',
      description: shopifyStore.description || shopifyStore.brand?.shortDescription || shopifyStore.brand?.slogan || aiContent.heroDescription,
      products: mappedProducts, 
      // collections: mappedCollections, // Removed from top level
      hero_image: heroImage,
      logo_url: logoUrl,
      theme: {
        primaryColor: primaryColor,
        secondaryColor: shopifyStore.brand?.colors?.secondary?.[0]?.background || getRandomColor(),
        fontFamily: getRandomFont(), 
        layout: getRandomLayout(),
      },
      content: {
          ...aiContent, // Keep base AI content
          heroTitle: `Welcome to ${shopifyStore.name}`,
          heroDescription: shopifyStore.description || shopifyStore.brand?.shortDescription || shopifyStore.brand?.slogan || aiContent.heroDescription,
          // Add other brand elements if available
          brandSlogan: shopifyStore.brand?.slogan,
          brandShortDescription: shopifyStore.brand?.shortDescription,
      },
      data_source: 'shopify',
      card_background_url: cardBackgroundUrlShopify
      // The 'shopify_data' field containing domain, raw_metadata, and collections
      // is removed here to prevent Supabase errors if the column doesn't exist.
      // If this data needs to be persisted, a 'shopify_data' JSONB column
      // should be added to the 'stores' table in Supabase, and the commented-out
      // 'shopify_data' object below should be reinstated.
      // shopify_data: {
      //   domain: domain,
      //   raw_metadata: shopifyStore,
      //   collections: mappedCollections,
      // }
    };
};

// This function is now a wrapper that calls the mapping function.
// It will be called at the end of the wizard.
export const importShopifyStoreData = async (domain, token, shopifyStoreRaw, shopifyProductsRaw, shopifyCollectionsRaw, { generateId = utilGenerateId } = {}) => {
    // This function now assumes shopifyStoreRaw, shopifyProductsRaw, shopifyCollectionsRaw are already fetched and passed.
    // If they are not passed, it implies an error or a different flow.
    // For the wizard, these will be populated from previous steps.
    if (!shopifyStoreRaw || !shopifyProductsRaw || !shopifyCollectionsRaw) {
        // This case should ideally not be hit if the wizard flow is correct.
        // Fallback to old behavior if data isn't pre-fetched (though this path should be deprecated by wizard)
        console.warn("importShopifyStoreData called without pre-fetched data. Consider updating flow.");
        const tempShopData = await fetchShopifyStoreMetadata(domain, token);
        // Fetch all products and collections for simplicity in this fallback.
        // In a real scenario, you'd handle pagination properly here if this path was still active.
        const tempProductsData = await fetchShopifyProductsList(domain, token, 250); // Max items
        const tempCollectionsData = await fetchShopifyCollectionsList(domain, token, 50); // Max items

        return await mapShopifyDataToInternalStore( // Added await
            tempShopData, 
            tempProductsData.edges.map(e => e.node), 
            tempCollectionsData.edges.map(e => e.node), 
            domain, 
            { generateId }
        );
    }

    return await mapShopifyDataToInternalStore( // Added await
        shopifyStoreRaw, 
        shopifyProductsRaw, // Assuming this is an array of product nodes
        shopifyCollectionsRaw, // Assuming this is an array of collection nodes
        domain, 
        { generateId }
    );
};

// Placeholder for BigCommerce data mapping
export const mapBigCommerceDataToInternalStore = async (bcStoreSettings, bcProducts, domain, { generateId = utilGenerateId } = {}, generatedLogoDataUrl = null) => {
  console.log("Mapping BigCommerce Data:", { bcStoreSettings, bcProducts, domain, generatedLogoDataUrl });

  const mappedProducts = bcProducts.map(p => ({
    id: p.entityId?.toString() || `bc-product-${generateId()}`, // Ensure ID is a string
    name: p.name || "Unnamed Product",
    description: p.description || `Product: ${p.name || "Unnamed Product"}`, // BC GraphQL might not provide full descriptions easily
    price: parseFloat(p.prices?.price?.value || 0),
    currencyCode: p.prices?.price?.currencyCode || 'USD',
    image: {
      id: `bc-img-${generateId()}`,
      src: { medium: p.defaultImage?.url || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.name || "Product")}` },
      alt: p.defaultImage?.altText || p.name || "Product Image",
    },
    sku: p.sku || '',
    // Add other fields from BigCommerce product data if needed
    rating: (Math.random() * 1.5 + 3.5).toFixed(1), 
    stock: Math.floor(Math.random() * 100) + 10, 
  }));

  // Placeholder for BigCommerce collection mapping - BC API for collections is different
  // For now, let's add some AI generated collections as a placeholder
  // const mappedCollections = []; // Replace with actual BC collection mapping if API is integrated
  const aiCollectionsForBC = []; // Removed generateAICollections call for now to simplify


  const logoUrl = generatedLogoDataUrl || bcStoreSettings.logo?.image?.url || `https://via.placeholder.com/100x100.png?text=${(bcStoreSettings.storeName || "S").substring(0,1)}`;
  const aiContent = generateAIStoreContent('general', bcStoreSettings.storeName || "My BigCommerce Store");
  const cardBgImagesBC = await utilFetchPexelsImages(`${bcStoreSettings.storeName || "store"} background`, 1, 'landscape');
  const cardBackgroundUrlBC = cardBgImagesBC[0]?.src?.large || cardBgImagesBC[0]?.src?.original || '';

  return {
    id: `store-bc-${(bcStoreSettings.storeHash || domain).replace(/[\.\/\:]/g, '-')}-${generateId()}`,
    name: bcStoreSettings.storeName || "My BigCommerce Store",
    type: 'bigcommerce-imported',
    description: bcStoreSettings.description || `Store imported from ${domain}` || aiContent.heroDescription,
    products: mappedProducts,
    // collections: aiCollectionsForBC, // Removed AI-generated collections for BC for now
    hero_image: { 
        id: generateId(),
        src: { large: bcStoreSettings.logo?.image?.url || `https://via.placeholder.com/1200x800.png?text=${encodeURIComponent(bcStoreSettings.storeName || "Store")}` }, 
        alt: bcStoreSettings.logo?.image?.altText || bcStoreSettings.storeName || "Store Hero"
    },
    logo_url: logoUrl,
    theme: {
      primaryColor: getRandomColor(),
      secondaryColor: getRandomColor(),
      fontFamily: getRandomFont(),
      layout: getRandomLayout(),
    },
    content: {
        ...aiContent,
        heroTitle: `Welcome to ${bcStoreSettings.storeName || "Our Store"}`,
        heroDescription: bcStoreSettings.description || aiContent.heroDescription,
    },
    data_source: 'bigcommerce',
    card_background_url: cardBackgroundUrlBC,
    // bigcommerce_data: { // Optional: store raw data if needed
    //   domain: domain,
    //   raw_settings: bcStoreSettings,
    // }
  };
};

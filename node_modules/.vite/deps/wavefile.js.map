{
  "version": 3,
  "sources": ["../../wavefile/lib/parsers/base64-arraybuffer.js", "../../wavefile/lib/codecs/bitdepth.js", "../../wavefile/lib/codecs/imaadpcm.js", "../../wavefile/lib/codecs/alaw.js", "../../wavefile/lib/codecs/mulaw.js", "../../wavefile/lib/parsers/binary/lib/endianness.js", "../../wavefile/lib/parsers/binary/lib/utf8-parser.js", "../../wavefile/lib/parsers/binary/lib/int-parser.js", "../../wavefile/lib/parsers/binary/lib/float-parser.js", "../../wavefile/lib/parsers/binary/index.js", "../../wavefile/lib/riff-file.js", "../../wavefile/lib/wavefile-reader.js", "../../wavefile/lib/parsers/write-string.js", "../../wavefile/lib/wavefile-parser.js", "../../wavefile/lib/parsers/interleave.js", "../../wavefile/lib/validators/validate-num-channels.js", "../../wavefile/lib/validators/validate-sample-rate.js", "../../wavefile/lib/wavefile-creator.js", "../../wavefile/lib/wavefile-tag-editor.js", "../../wavefile/lib/wavefile-cue-editor.js", "../../wavefile/lib/resampler/interpolator.js", "../../wavefile/lib/resampler/fir-lpf.js", "../../wavefile/lib/resampler/butterworth-lpf.js", "../../wavefile/lib/resampler/index.js", "../../wavefile/lib/wavefile-converter.js", "../../wavefile/index.js"],
  "sourcesContent": ["/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n/**\r\n * Encode a byte buffer as a base64 string.\r\n * @param {!Uint8Array} bytes The buffer.\r\n * @return {string} A .wav file as a DataURI.\r\n */\r\nexport function encode(bytes) {\r\n  /** @type {string} */\r\n  let base64 = '';\r\n  for (let i = 0; i < bytes.length; i += 3) {\r\n    base64 += chars[bytes[i] >> 2];\r\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\r\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\r\n    base64 += chars[bytes[i + 2] & 63];\r\n  }\r\n  if (bytes.length % 3 === 2) {\r\n    base64 = base64.substring(0, base64.length - 1) + '=';\r\n  } else if (bytes.length % 3 === 1) {\r\n    base64 = base64.substring(0, base64.length - 2) + '==';\r\n  }\r\n  return base64;\r\n}\r\n\r\n/**\r\n * Decode a base64 string as a byte as buffer.\r\n * @param {string} base64 A .wav file as a DataURI.\r\n * @return {!Uint8Array} A .wav file as a DataURI.\r\n */\r\nexport function decode(base64) {\r\n  /** @type {!Uint8Array} */\r\n  let lookup = new Uint8Array(256);\r\n  for (let i = 0; i < chars.length; i++) {\r\n    lookup[chars.charCodeAt(i)] = i;\r\n  }\r\n  /** @type {number} */\r\n  let bufferLength = base64.length * 0.75;\r\n  if (base64[base64.length - 1] === '=') {\r\n    bufferLength--;\r\n    if (base64[base64.length - 2] === '=') {\r\n      bufferLength--;\r\n    }\r\n  }\r\n  /** @type {!Uint8Array} */\r\n  let bytes = new Uint8Array(bufferLength);\r\n  for (let i = 0, j = 0; i < base64.length; i += 4) {\r\n    /** @type {number} */\r\n    let encoded1 = lookup[base64.charCodeAt(i)];\r\n    /** @type {number} */\r\n    let encoded2 = lookup[base64.charCodeAt(i + 1)];\r\n    /** @type {number} */\r\n    let encoded3 = lookup[base64.charCodeAt(i + 2)];\r\n    /** @type {number} */\r\n    let encoded4 = lookup[base64.charCodeAt(i + 3)];\r\n    bytes[j++] = encoded1 << 2 | encoded2 >> 4;\r\n    bytes[j++] = (encoded2 & 15) << 4 | encoded3 >> 2;\r\n    bytes[j++] = (encoded3 & 3) << 6 | encoded4 & 63;\r\n  }\r\n  return bytes;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A module to change the bit depth of PCM samples.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/bitdepth\r\n */\r\n\r\n/**\r\n * Change the bit depth of PCM samples.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {string} bithDepth The original bit depth.\r\n * @param {!TypedArray} newSamples The output array.\r\n * @param {string} targetBitDepth The target bit depth.\r\n * @throws {Error} If original or target bit depths are not valid.\r\n */\r\nexport function changeBitDepth(samples, bithDepth, newSamples, targetBitDepth) {\r\n  // float to float, just copy the values\r\n  if ([\"32f\",\"64\"].indexOf(bithDepth) > -1 &&\r\n    [\"32f\",\"64\"].indexOf(targetBitDepth) > -1) {\r\n    newSamples.set(samples);\r\n    return;\r\n  }\r\n  validateBitDepth_(bithDepth);\r\n  validateBitDepth_(targetBitDepth);\r\n  /** @type {!Function} */\r\n  let toFunction = getBitDepthFunction_(bithDepth, targetBitDepth);\r\n  /** @type {!Object<string, number>} */\r\n  let options = {\r\n    oldMin: Math.pow(2, parseInt(bithDepth, 10)) / 2,\r\n    newMin: Math.pow(2, parseInt(targetBitDepth, 10)) / 2,\r\n    oldMax: (Math.pow(2, parseInt(bithDepth, 10)) / 2) - 1,\r\n    newMax: (Math.pow(2, parseInt(targetBitDepth, 10)) / 2) - 1,\r\n  };\r\n  // sign the samples if original is 8-bit\r\n  sign8Bit_(bithDepth, samples, true);\r\n  // change the resolution of the samples\r\n  for (let i = 0, len = samples.length; i < len; i++) {        \r\n    newSamples[i] = toFunction(samples[i], options);\r\n  }\r\n  // unsign the samples if target is 8-bit\r\n  sign8Bit_(targetBitDepth, newSamples, false);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToInt_(sample, args) {\r\n  if (sample > 0) {\r\n    sample = parseInt((sample / args.oldMax) * args.newMax, 10);\r\n  } else {\r\n    sample = parseInt((sample / args.oldMin) * args.newMin, 10);\r\n  }\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToInt_(sample, args) {\r\n  return parseInt(\r\n    sample > 0 ? sample * args.newMax : sample * args.newMin, 10);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to float.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToFloat_(sample, args) {\r\n  return sample > 0 ? sample / args.oldMax : sample / args.oldMin;\r\n}\r\n\r\n/**\r\n * Return the function to change the bit depth of a sample.\r\n * @param {string} original The original bit depth of the data.\r\n * @param {string} target The new bit depth of the data.\r\n * @return {!Function}\r\n * @private\r\n */\r\nfunction getBitDepthFunction_(original, target) {\r\n  /** @type {!Function} */\r\n  let func = function(x) {return x;};\r\n  if (original != target) {\r\n    if ([\"32f\", \"64\"].includes(original)) {\r\n      func = floatToInt_;\r\n    } else {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = intToFloat_;\r\n      } else {\r\n        func = intToInt_;\r\n      }\r\n    }\r\n  }\r\n  return func;\r\n}\r\n\r\n/**\r\n * Validate the bit depth.\r\n * @param {string} bitDepth The original bit depth.\r\n * @throws {Error} If bit depth is not valid.\r\n * @private\r\n */\r\nfunction validateBitDepth_(bitDepth) {\r\n  if ((bitDepth != \"32f\" && bitDepth != \"64\") &&\r\n      (parseInt(bitDepth, 10) < \"8\" || parseInt(bitDepth, 10) > \"53\")) {\r\n    throw new Error(\"Invalid bit depth.\");\r\n  }\r\n}\r\n\r\n/**\r\n * Sign samples if they are 8-bit.\r\n * @param {string} bitDepth The bit depth code.\r\n * @param {!Array|!TypedArray} samples The samples.\r\n * @param {boolean} sign True to sign, false to unsign.\r\n * @private\r\n */\r\nfunction sign8Bit_(bitDepth, samples, sign) {\r\n  if (bitDepth == \"8\") {\r\n    let factor = sign ? -128 : 128;\r\n    for (let i = 0, len = samples.length; i < len; i++) {\r\n      samples[i] = samples[i] += factor;\r\n    }\r\n  }\r\n}\r\n", "/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2016 acida. MIT License.  \r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview IMA ADPCM codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/imaadpcm\r\n */\r\n\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst INDEX_TABLE = [\r\n    -1, -1, -1, -1, 2, 4, 6, 8,\r\n    -1, -1, -1, -1, 2, 4, 6, 8];\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst STEP_TABLE = [\r\n    7, 8, 9, 10, 11, 12, 13, 14,\r\n    16, 17, 19, 21, 23, 25, 28, 31,\r\n    34, 37, 41, 45, 50, 55, 60, 66,\r\n    73, 80, 88, 97, 107, 118, 130, 143,\r\n    157, 173, 190, 209, 230, 253, 279, 307,\r\n    337, 371, 408, 449, 494, 544, 598, 658,\r\n    724, 796, 876, 963, 1060, 1166, 1282, 1411,\r\n    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\r\n    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,\r\n    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\r\n    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n    32767];\r\n\r\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Int16Array} samples A array of samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Uint8Array} */\r\n  let adpcmSamples = new Uint8Array((samples.length));\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  /** @type {number} */\r\n  let blockCount = 0;\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    if ((i % 505 == 0 && i != 0)) {\r\n      adpcmSamples.set(encodeBlock(block, state), fileIndex);\r\n      fileIndex += 256;\r\n      block = [];\r\n      blockCount++;\r\n    }\r\n    block.push(samples[i]);\r\n  }\r\n  let samplesLength = samples.length / 2;\r\n  if (samplesLength % 2) {\r\n    samplesLength++;\r\n  }\r\n  return adpcmSamples.slice(0, samplesLength + 512 + blockCount * 4);\r\n}\r\n\r\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(adpcmSamples, blockAlign=256) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Int16Array} */\r\n  let samples = new Int16Array(adpcmSamples.length * 2);\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  for (let i = 0, len = adpcmSamples.length; i < len; i++) {\r\n    if (i % blockAlign == 0 && i != 0) {            \r\n      let decoded = decodeBlock(block, state);\r\n      samples.set(decoded, fileIndex);\r\n      fileIndex += decoded.length;\r\n      block = [];\r\n    }\r\n    block.push(adpcmSamples[i]);\r\n  }\r\n  return samples;\r\n}\r\n\r\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction encodeBlock(block, state) {\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = blockHead_(block[0], state);\r\n  for (let i = 3, len = block.length; i < len; i+=2) {\r\n    /** @type {number} */\r\n    let sample2 = encodeSample_(block[i], state);\r\n    /** @type {number} */\r\n    let sample = encodeSample_(block[i + 1], state);\r\n    adpcmSamples.push((sample << 4) | sample2);\r\n  }\r\n  return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @param {!Object} state The decoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction decodeBlock(block, state) {\r\n  state.predicted = sign_((block[1] << 8) | block[0]);\r\n  state.index = block[2];\r\n  state.step = STEP_TABLE[state.index];\r\n  /** @type {!Array<number>} */\r\n  let result = [\r\n      state.predicted,\r\n      state.predicted\r\n    ];\r\n  for (let i = 4, len = block.length; i < len; i++) {\r\n    /** @type {number} */\r\n    let original_sample = block[i];\r\n    /** @type {number} */\r\n    let second_sample = original_sample >> 4;\r\n    /** @type {number} */\r\n    let first_sample = (second_sample << 4) ^ original_sample;\r\n    result.push(decodeSample_(first_sample, state));\r\n    result.push(decodeSample_(second_sample, state));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sign_(num) {\r\n  return num > 32768 ? num - 65536 : num;\r\n}\r\n\r\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @param {!Object} state The encoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction encodeSample_(sample, state) {\r\n  /** @type {number} */\r\n  let delta = sample - state.predicted;\r\n  /** @type {number} */\r\n  let value = 0;\r\n  if (delta >= 0) {\r\n    value = 0;\r\n  } else {\r\n    value = 8;\r\n    delta = -delta;\r\n  }\r\n  /** @type {number} */\r\n  let step = STEP_TABLE[state.index];\r\n  /** @type {number} */\r\n  let diff = step >> 3;\r\n  if (delta > step) {\r\n    value |= 4;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 2;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 1;\r\n    diff += step;\r\n  }\r\n  updateEncoder_(value, diff, state);\r\n  return value;\r\n}\r\n\r\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @param {!Object} state The encoder state.\r\n * @private\r\n */\r\nfunction updateEncoder_(value, diff, state) {\r\n  if (value & 8) {\r\n    state.predicted -= diff;\r\n  } else {\r\n    state.predicted += diff;\r\n  }\r\n  if (state.predicted < -0x8000) {\r\n    state.predicted = -0x8000;\r\n  } else if (state.predicted > 0x7fff) {\r\n    state.predicted = 0x7fff;\r\n  }\r\n  state.index += INDEX_TABLE[value & 7];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n}\r\n\r\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction decodeSample_(nibble, state) {\r\n  /** @type {number} */\r\n  let difference = 0;\r\n  if (nibble & 4) {\r\n    difference += state.step;\r\n  }\r\n  if (nibble & 2) {\r\n    difference += state.step >> 1;\r\n  }\r\n  if (nibble & 1) {\r\n    difference += state.step >> 2;\r\n  }\r\n  difference += state.step >> 3;\r\n  if (nibble & 8) {\r\n    difference = -difference;\r\n  }\r\n  state.predicted += difference;\r\n  if (state.predicted > 32767) {\r\n    state.predicted = 32767;\r\n  } else if (state.predicted < -32767) {\r\n    state.predicted = -32767;\r\n  }\r\n  updateDecoder_(nibble, state);\r\n  return state.predicted;\r\n}\r\n\r\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @private\r\n */\r\nfunction updateDecoder_(nibble, state) {\r\n  state.index += INDEX_TABLE[nibble];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n  state.step = STEP_TABLE[state.index];\r\n}\r\n\r\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction blockHead_(sample, state) {\r\n  encodeSample_(sample, state);\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = [];\r\n  adpcmSamples.push(sample & 0xFF);\r\n  adpcmSamples.push((sample >> 8) & 0xFF);\r\n  adpcmSamples.push(state.index);\r\n  adpcmSamples.push(0);\r\n  return adpcmSamples;\r\n}\r\n", "/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A-Law codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/alawmulaw\r\n */\r\n\r\n/** @type {!Array<number>} */\r\nconst LOG_TABLE = [\r\n  1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, \r\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 \r\n];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit A-Law.\r\n * @param {number} sample A 16-bit PCM sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(sample) {\r\n  /** @type {number} */\r\n  let compandedValue; \r\n  sample = (sample ==-32768) ? -32767 : sample;\r\n  /** @type {number} */\r\n  let sign = ((~sample) >> 8) & 0x80; \r\n  if (!sign) {\r\n    sample = sample * -1; \r\n  }\r\n  if (sample > 32635) {\r\n    sample = 32635; \r\n  }\r\n  if (sample >= 256)  {\r\n    /** @type {number} */\r\n    let exponent = LOG_TABLE[(sample >> 8) & 0x7F];\r\n    /** @type {number} */\r\n    let mantissa = (sample >> (exponent + 3) ) & 0x0F; \r\n    compandedValue = ((exponent << 4) | mantissa); \r\n  } else {\r\n    compandedValue = sample >> 4; \r\n  } \r\n  return compandedValue ^ (sign ^ 0x55);\r\n}\r\n\r\n/**\r\n * Decode a 8-bit A-Law sample as 16-bit PCM.\r\n * @param {number} aLawSample The 8-bit A-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(aLawSample) {\r\n  /** @type {number} */\r\n  let sign = 0;\r\n  aLawSample ^= 0x55;\r\n  if ((aLawSample & 0x80) !== 0) {\r\n    aLawSample &= ~(1 << 7);\r\n    sign = -1;\r\n  }\r\n  /** @type {number} */\r\n  let position = ((aLawSample & 0xF0) >> 4) + 4;\r\n  /** @type {number} */\r\n  let decoded = 0;\r\n  if (position != 4) {\r\n    decoded = ((1 << position) |\r\n      ((aLawSample & 0x0F) << (position - 4)) |\r\n      (1 << (position - 5)));\r\n  } else {\r\n    decoded = (aLawSample << 1)|1;\r\n  }\r\n  decoded = (sign === 0) ? (decoded) : (-decoded);\r\n  return (decoded * 8) * -1;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples as 8-bit A-Law samples.\r\n * @param {!Int16Array} samples A array of 16-bit PCM samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Uint8Array} */\r\n  let aLawSamples = new Uint8Array(samples.length);\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    aLawSamples[i] = encodeSample(samples[i]);\r\n  }\r\n  return aLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit A-Law samples into 16-bit linear PCM samples.\r\n * @param {!Uint8Array} samples A array of 8-bit A-Law samples.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Int16Array} */\r\n  let pcmSamples = new Int16Array(samples.length);\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    pcmSamples[i] = decodeSample(samples[i]);\r\n  }\r\n  return pcmSamples;\r\n}\r\n", "/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview mu-Law codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/alawmulaw\r\n */\r\n\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst BIAS = 0x84;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst CLIP = 32635;\r\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\r\nconst encodeTable = [\r\n    0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\r\n    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\r\n    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\r\n    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\r\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7];\r\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\r\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit mu-Law.\r\n * @param {number} sample A 16-bit PCM sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(sample) {\r\n  /** @type {number} */\r\n  let sign;\r\n  /** @type {number} */\r\n  let exponent;\r\n  /** @type {number} */\r\n  let mantissa;\r\n  /** @type {number} */\r\n  let muLawSample;\r\n  /** get the sample into sign-magnitude **/\r\n  sign = (sample >> 8) & 0x80;\r\n  if (sign != 0) sample = -sample;\r\n  /** convert from 16 bit linear to ulaw **/\r\n  sample = sample + BIAS;\r\n  if (sample > CLIP) sample = CLIP;\r\n  exponent = encodeTable[(sample>>7) & 0xFF];\r\n  mantissa = (sample >> (exponent+3)) & 0x0F;\r\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\r\n  /** return the result **/\r\n  return muLawSample;\r\n}\r\n\r\n/**\r\n * Decode a 8-bit mu-Law sample as 16-bit PCM.\r\n * @param {number} muLawSample The 8-bit mu-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(muLawSample) {\r\n  /** @type {number} */\r\n  let sign;\r\n  /** @type {number} */\r\n  let exponent;\r\n  /** @type {number} */\r\n  let mantissa;\r\n  /** @type {number} */\r\n  let sample;\r\n  muLawSample = ~muLawSample;\r\n  sign = (muLawSample & 0x80);\r\n  exponent = (muLawSample >> 4) & 0x07;\r\n  mantissa = muLawSample & 0x0F;\r\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\r\n  if (sign != 0) sample = -sample;\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit mu-Law samples.\r\n * @param {!Int16Array} samples A array of 16-bit PCM samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Uint8Array} */\r\n  let muLawSamples = new Uint8Array(samples.length);\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    muLawSamples[i] = encodeSample(samples[i]);\r\n  }\r\n  return muLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit mu-Law samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} samples A array of 8-bit mu-Law samples.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Int16Array} */\r\n  let pcmSamples = new Int16Array(samples.length);\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    pcmSamples[i] = decodeSample(samples[i]);\r\n  }\r\n  return pcmSamples;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A function to swap endianness in byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * Swap the byte ordering in a buffer. The buffer is modified in place.\r\n * @param {!(Array<number>|Uint8Array)} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number=} [start=0] The start index.\r\n * @param {number=} [end=bytes.length] The end index.\r\n */\r\nexport function endianness(bytes, offset, start=0, end=bytes.length) {\r\n  for (let index = start; index < end; index += offset) {\r\n    swap_(bytes, offset, index);\r\n  }\r\n}\r\n\r\n/**\r\n * Swap the byte order of a value in a buffer. The buffer is modified in place.\r\n * @param {!(Array<number>|Uint8Array)} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number} index The start index.\r\n * @private\r\n */\r\nfunction swap_(bytes, offset, index) {\r\n  offset--;\r\n  for(let x = 0; x < offset; x++) {\r\n    /** @type {number} */\r\n    let theByte = bytes[index + x];\r\n    bytes[index + x] = bytes[index + offset];\r\n    bytes[index + offset] = theByte;\r\n    offset--;\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode UTF8 strings to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=0] The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\r\nexport function unpack(buffer, start=0, end=buffer.length) {\r\n  /** @type {string} */\r\n  let str = '';\r\n  for(let index = start; index < end;) {\r\n    /** @type {number} */\r\n    let lowerBoundary = 0x80;\r\n    /** @type {number} */\r\n    let upperBoundary = 0xBF;\r\n    /** @type {boolean} */\r\n    let replace = false;\r\n    /** @type {number} */\r\n    let charCode = buffer[index++];\r\n    if (charCode >= 0x00 && charCode <= 0x7F) {\r\n      str += String.fromCharCode(charCode);\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\r\n        count = 1;\r\n      } else if (charCode >= 0xE0 && charCode <= 0xEF ) {\r\n        count = 2;\r\n        if (buffer[index] === 0xE0) {\r\n          lowerBoundary = 0xA0;\r\n        }\r\n        if (buffer[index] === 0xED) {\r\n          upperBoundary = 0x9F;\r\n        }\r\n      } else if (charCode >= 0xF0 && charCode <= 0xF4 ) {\r\n        count = 3;\r\n        if (buffer[index] === 0xF0) {\r\n          lowerBoundary = 0x90;\r\n        }\r\n        if (buffer[index] === 0xF4) {\r\n          upperBoundary = 0x8F;\r\n        }\r\n      } else {\r\n        replace = true;\r\n      }\r\n      charCode = charCode & (1 << (8 - count - 1)) - 1;\r\n      for (let i = 0; i < count; i++) {\r\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\r\n          replace = true;\r\n        }\r\n        charCode = (charCode << 6) | (buffer[index] & 0x3f);\r\n        index++;\r\n      }\r\n      if (replace) {\r\n        str += String.fromCharCode(0xFFFD);\r\n      } \r\n      else if (charCode <= 0xffff) {\r\n        str += String.fromCharCode(charCode);\r\n      } else {\r\n        charCode -= 0x10000;\r\n        str += String.fromCharCode(\r\n          ((charCode >> 10) & 0x3ff) + 0xd800,\r\n          (charCode & 0x3ff) + 0xdc00);\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function pack(str, buffer, index=0) {\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let len = str.length;\r\n  while (i < len) {\r\n    /** @type {number} */\r\n    let codePoint = str.codePointAt(i);\r\n    if (codePoint < 128) {\r\n      buffer[index] = codePoint;\r\n      index++;\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      /** @type {number} */\r\n      let offset = 0;\r\n      if (codePoint <= 0x07FF) {\r\n        count = 1;\r\n        offset = 0xC0;\r\n      } else if(codePoint <= 0xFFFF) {\r\n        count = 2;\r\n        offset = 0xE0;\r\n      } else if(codePoint <= 0x10FFFF) {\r\n        count = 3;\r\n        offset = 0xF0;\r\n        i++;\r\n      }\r\n      buffer[index] = (codePoint >> (6 * count)) + offset;\r\n      index++;\r\n      while (count > 0) {\r\n        buffer[index] = 0x80 | (codePoint >> (6 * (count - 1)) & 0x3F);\r\n        index++;\r\n        count--;\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return index;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\r\nexport class IntParser {\r\n  \r\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\r\n  constructor(bits, signed=false) {\r\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil(bits / 8);\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.max = Math.pow(2, bits) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.min = 0;\r\n    /**\r\n     * @type {Function}\r\n     */\r\n    this.unpack = this.unpack_;\r\n    if (signed) {\r\n      this.max = Math.pow(2, bits) / 2 - 1;\r\n      this.min = -this.max - 1;\r\n      this.unpack = this.unpackSigned_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  pack(buffer, num, index=0) {\r\n    num = this.clamp_(Math.round(num));\r\n    for (let i = 0, len = this.offset; i < len; i++) {\r\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\r\n      index++;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpack_(buffer, index=0) {\r\n    /** @type {number} */\r\n    let num = 0;\r\n    for(let x = 0; x < this.offset; x++) {\r\n      num += buffer[index + x] * Math.pow(256, x);\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpackSigned_(buffer, index=0) {\r\n    return this.sign_(this.unpack_(buffer, index));\r\n  }\r\n\r\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  clamp_(num) {\r\n    if (num > this.max) {\r\n      return this.max;\r\n    } else if (num < this.min) {\r\n      return this.min;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\r\n\r\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\r\nexport class FloatParser {\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\r\n  constructor(ebits, fbits) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil((ebits + fbits) / 8);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebits = ebits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbits = fbits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bias = (1 << (ebits - 1)) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.biasP2 = Math.pow(2, this.bias + 1);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebitsFbits = (ebits + fbits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\r\n  pack(buffer, num, index) {\r\n    // Round overflows\r\n    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {\r\n      num = num < 0 ? -Infinity : Infinity;\r\n    }\r\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\r\n    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;\r\n    num = Math.abs(num);\r\n    /** @type {number} */\r\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\r\n    /** @type {number} */\r\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\r\n    // NaN\r\n    if (num !== num) {\r\n      fraction = Math.pow(2, this.fbits - 1);\r\n      exp = (1 << this.ebits) - 1;\r\n    // Number\r\n    } else if (num !== 0) {\r\n      if (num >= Math.pow(2, 1 - this.bias)) {\r\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\r\n          exp = exp + 1;\r\n          fraction = 1;\r\n        }\r\n        // Overflow\r\n        if (exp > this.bias) {\r\n          exp = (1 << this.ebits) - 1;\r\n          fraction = 0;\r\n        } else {\r\n          exp = exp + this.bias;\r\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\r\n        }\r\n      } else {\r\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\r\n        exp = 0;\r\n      } \r\n    }\r\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\r\n  }\r\n\r\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\r\n  unpack(buffer, index) {\r\n    /** @type {number} */\r\n    let eMax = (1 << this.ebits) - 1;\r\n    /** @type {number} */\r\n    let significand;\r\n    /** @type {string} */\r\n    let leftBits = \"\";\r\n    for (let i = this.offset - 1; i >= 0 ; i--) {\r\n      /** @type {string} */\r\n      let t = buffer[i + index].toString(2);\r\n      leftBits += \"00000000\".substring(t.length) + t;\r\n    }\r\n    /** @type {number} */\r\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\r\n    leftBits = leftBits.substring(1);\r\n    /** @type {number} */\r\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\r\n    leftBits = leftBits.substring(this.ebits);\r\n    if (exponent == eMax) {\r\n      if (parseInt(leftBits, 2) !== 0) {\r\n        return NaN;\r\n      }\r\n      return sign * Infinity;  \r\n    } else if (exponent === 0) {\r\n      exponent += 1;\r\n      significand = parseInt(leftBits, 2);\r\n    } else {\r\n      significand = parseInt(\"1\" + leftBits, 2);\r\n    }\r\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  packFloatBits_(buffer, index, sign, exp, fraction) {\r\n    /** @type {!Array<number>} */\r\n    let bits = [];\r\n    // the sign\r\n    bits.push(sign);\r\n    // the exponent\r\n    for (let i = this.ebits; i > 0; i -= 1) {\r\n      bits[i] = (exp % 2 ? 1 : 0);\r\n      exp = Math.floor(exp / 2);\r\n    }\r\n    // the fraction\r\n    let len = bits.length;\r\n    for (let i = this.fbits; i > 0; i -= 1) {\r\n      bits[len + i] = (fraction % 2 ? 1 : 0);\r\n      fraction = Math.floor(fraction / 2);\r\n    }\r\n    // pack as bytes\r\n    /** @type {string} */\r\n    let str = bits.join('');\r\n    /** @type {number} */\r\n    let offset = this.offset + index - 1;\r\n    /** @type {number} */\r\n    let k = index;\r\n    while (offset >= index) {\r\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\r\n      str = str.substring(8);\r\n      offset--;\r\n      k++;\r\n    }\r\n    return k;\r\n  }\r\n}\r\n\r\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction roundToEven(n) {\r\n  /** @type {number} */\r\n  let w = Math.floor(n);\r\n  let f = n - w;\r\n  if (f < 0.5) {\r\n    return w;\r\n  }\r\n  if (f > 0.5) {\r\n    return w + 1;\r\n  }\r\n  return w % 2 ? w + 1 : w;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview binary parser.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { endianness } from './lib/endianness';\r\nimport { pack as packUTF8, unpack as unpackUTF8 } from './lib/utf8-parser';\r\nimport { IntParser } from './lib/int-parser';\r\nimport { FloatParser } from './lib/float-parser';\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\r\nexport function unpackString(buffer, index=0, end=buffer.length) {\r\n  return unpackUTF8(buffer, index, end);\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\r\nexport function packString(str) {\r\n  /** @type {!Array<number>} */\r\n  let buffer = [];\r\n  packUTF8(str, buffer);\r\n  return buffer;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function packStringTo(str, buffer, index=0) {\r\n  return packUTF8(str, buffer, index);\r\n}\r\n\r\n// Numbers\r\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packArrayTo(values, theType, buffer, index=0) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let packer = getParser_(theType.bits, theType.fp, theType.signed);\r\n  /** @type {number} */\r\n  let offset = Math.ceil(theType.bits / 8);\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let start = index;\r\n  for (let valuesLen = values.length; i < valuesLen; i++) {\r\n    index = packer.pack(buffer, values[i], index);\r\n  }\r\n  if (theType.be) {\r\n    endianness(buffer, offset, start, index);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpackArrayTo(\r\n    buffer, theType, output, start=0, end=buffer.length) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let parser = getParser_(theType.bits, theType.fp, theType.signed);\r\n  // getUnpackLen_ will adjust the end index according to the size\r\n  // of the input buffer and the byte offset or throw a error on bad\r\n  // end index if safe=true\r\n  end = getUnpackLen_(buffer, start, end, parser.offset);\r\n  if (theType.be) {\r\n    /** @type {!(Uint8Array|Array<number>)} */\r\n    let readBuffer = copyBuffer_(buffer);\r\n    if (theType.be) {\r\n      endianness(readBuffer, parser.offset, start, end);\r\n    }\r\n    unpack_(readBuffer, output, start, end, parser);\r\n  } else {\r\n    unpack_(buffer, output, start, end, parser);\r\n  }\r\n}\r\n\r\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packTo(value, theType, buffer, index=0) {\r\n  return packArrayTo([value], theType, buffer, index);\r\n}\r\n\r\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function pack(value, theType) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  packTo(value, theType, output, 0);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpack(buffer, theType, index=0) {\r\n  let output = [];\r\n  unpackArrayTo(buffer, theType, output,\r\n    index, index + Math.ceil(theType.bits / 8));\r\n  return output[0];\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {!Object} parser The parser.\r\n * @private\r\n */\r\nfunction unpack_(buffer, output, start, end, parser) {\r\n  /** @type {number} */\r\n  let offset = parser.offset;\r\n  for (let index = 0, j = start; j < end; j += offset, index++) {\r\n    output[index] = parser.unpack(buffer, j);\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a byte buffer as a Array or Uint8Array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @return {!(Uint8Array|Array<number>)}\r\n * @private\r\n */\r\nfunction copyBuffer_(buffer) {\r\n  return new Uint8Array(buffer);\r\n}\r\n\r\n/**\r\n * Adjust the end index according to the input buffer length and the\r\n * type offset.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @private\r\n */\r\nfunction getUnpackLen_(buffer, start, end, offset) {\r\n  /** @type {number} */\r\n  let extra = (end - start) % offset;\r\n  return end - extra;\r\n}\r\n\r\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\r\nfunction getParser_(bits, fp, signed) {\r\n  if (fp && bits == 32) {\r\n    return new FloatParser(8, 23);\r\n  } else if(fp && bits == 64) {\r\n    return new FloatParser(11, 52);\r\n  }\r\n  return new IntParser(bits, signed);\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\r\nexport class RIFFFile {\r\n\r\n  constructor() {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\r\n    this.signature = null;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.head = 0;\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt32 = {bits: 32, be: false};\r\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\r\n    this.supported_containers = ['RIFF', 'RIFX'];\r\n  }\r\n\r\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\r\n  setSignature(buffer) {\r\n    this.head = 0;\r\n    this.container = this.readString(buffer, 4);\r\n    if (this.supported_containers.indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.uInt32.be = this.container === 'RIFX';\r\n    this.chunkSize = this.readUInt32(buffer);\r\n    this.format = this.readString(buffer, 4);\r\n    // The RIFF file signature\r\n    this.signature = {\r\n      chunkId: this.container,\r\n      chunkSize: this.chunkSize,\r\n      format: this.format,\r\n      subChunks: this.getSubChunksIndex_(buffer)\r\n    };\r\n  }\r\n\r\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\r\n  findChunk(chunkId, multiple=false) {\r\n    /** @type {!Array<Object>} */\r\n    let chunks = this.signature.subChunks;\r\n    /** @type {!Array<Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i].chunkId == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\r\n  readString(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    str = unpackString(bytes, this.head, this.head + maxSize);\r\n    this.head += maxSize;\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\r\n  readUInt32(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt32, this.head);\r\n    this.head += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunksIndex_(buffer) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunks = [];\r\n    /** @type {number} */\r\n    let i = this.head;\r\n    while(i <= buffer.length - 8) {\r\n      chunks.push(this.getSubChunkIndex_(buffer, i));\r\n      i += 8 + chunks[chunks.length - 1].chunkSize;\r\n      i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n  }\r\n\r\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunkIndex_(buffer, index) {\r\n    /** @type {!Object} */\r\n    let chunk = {\r\n      chunkId: this.getChunkId_(buffer, index),\r\n      chunkSize: this.getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk.chunkId == 'LIST') {\r\n      chunk.format = unpackString(buffer, index + 8, index + 12);\r\n      this.head += 4;\r\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\r\n    } else {\r\n      /** @type {number} */\r\n      let realChunkSize = chunk.chunkSize % 2 ?\r\n        chunk.chunkSize + 1 : chunk.chunkSize;\r\n      this.head = index + 8 + realChunkSize;\r\n      chunk.chunkData = {\r\n        start: index + 8,\r\n        end: this.head\r\n      };\r\n    }\r\n    return chunk;\r\n  }\r\n\r\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\r\n  getChunkId_(buffer, index) {\r\n    this.head += 4;\r\n    return unpackString(buffer, index, index + 4);\r\n  }\r\n\r\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\r\n  getChunkSize_(buffer, index) {\r\n    this.head += 4;\r\n    return unpack(buffer, this.uInt32, index + 4);\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { RIFFFile } from './riff-file';\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\r\nexport class WaveFileReader extends RIFFFile {\r\n\r\n  constructor() {\r\n    super();\r\n    // Include 'RF64' as a supported container format\r\n    this.supported_containers.push('RF64');\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fmt = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      audioFormat: 0,\r\n      /** @type {number} */\r\n      numChannels: 0,\r\n      /** @type {number} */\r\n      sampleRate: 0,\r\n      /** @type {number} */\r\n      byteRate: 0,\r\n      /** @type {number} */\r\n      blockAlign: 0,\r\n      /** @type {number} */\r\n      bitsPerSample: 0,\r\n      /** @type {number} */\r\n      cbSize: 0,\r\n      /** @type {number} */\r\n      validBitsPerSample: 0,\r\n      /** @type {number} */\r\n      dwChannelMask: 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\r\n      subformat: []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fact = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwSampleLength: 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.cue = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwCuePoints: 0,\r\n      /** @type {!Array<!Object>} */\r\n      points: [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.smpl = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwManufacturer: 0,\r\n      /** @type {number} */\r\n      dwProduct: 0,\r\n      /** @type {number} */\r\n      dwSamplePeriod: 0,\r\n      /** @type {number} */\r\n      dwMIDIUnityNote: 0,\r\n      /** @type {number} */\r\n      dwMIDIPitchFraction: 0,\r\n      /** @type {number} */\r\n      dwSMPTEFormat: 0,\r\n      /** @type {number} */\r\n      dwSMPTEOffset: 0,\r\n      /** @type {number} */\r\n      dwNumSampleLoops: 0,\r\n      /** @type {number} */\r\n      dwSamplerData: 0,\r\n      /** @type {!Array<!Object>} */\r\n      loops: []\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.bext = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      description: '', //256\r\n      /** @type {string} */\r\n      originator: '', //32\r\n      /** @type {string} */\r\n      originatorReference: '', //32\r\n      /** @type {string} */\r\n      originationDate: '', //10\r\n      /** @type {string} */\r\n      originationTime: '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\r\n      timeReference: [0, 0],\r\n      /** @type {number} */\r\n      version: 0, //WORD\r\n      /** @type {string} */\r\n      UMID: '', // 64 chars\r\n      /** @type {number} */\r\n      loudnessValue: 0, //WORD\r\n      /** @type {number} */\r\n      loudnessRange: 0, //WORD\r\n      /** @type {number} */\r\n      maxTruePeakLevel: 0, //WORD\r\n      /** @type {number} */\r\n      maxMomentaryLoudness: 0, //WORD\r\n      /** @type {number} */\r\n      maxShortTermLoudness: 0, //WORD\r\n      /** @type {string} */\r\n      reserved: '', //180\r\n      /** @type {string} */\r\n      codingHistory: '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.iXML = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      riffSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      riffSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      originationTime: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountLow: 0 // DWORD\r\n      /** @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.data = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Uint8Array} */\r\n      samples: new Uint8Array(0)\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.junk = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Array<number>} */\r\n      chunkData: []\r\n    };\r\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this._PMX = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt16 = {bits: 16, be: false, signed: false, fp: false};\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    // Always should reset the chunks when reading from a buffer\r\n    this.clearHeaders();\r\n    this.setSignature(wavBuffer);\r\n    this.uInt16.be = this.uInt32.be;\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n    this.readDs64Chunk_(wavBuffer);\r\n    this.readFmtChunk_(wavBuffer);\r\n    this.readFactChunk_(wavBuffer);\r\n    this.readBextChunk_(wavBuffer);\r\n    this.readiXMLChunk_(wavBuffer);\r\n    this.readCueChunk_(wavBuffer);\r\n    this.readSmplChunk_(wavBuffer);\r\n    this.readDataChunk_(wavBuffer, samples);\r\n    this.readJunkChunk_(wavBuffer);\r\n    this.readLISTChunk_(wavBuffer);\r\n    this.read_PMXChunk_(wavBuffer);\r\n  }\r\n\r\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\r\n  clearHeaders() {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileReader();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.cue, tmpWav.cue);\r\n    Object.assign(this.smpl, tmpWav.smpl);\r\n    Object.assign(this.bext, tmpWav.bext);\r\n    Object.assign(this.iXML, tmpWav.iXML);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.LIST = [];\r\n    Object.assign(this.junk, tmpWav.junk);\r\n    Object.assign(this._PMX, tmpWav._PMX);\r\n  }\r\n  \r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fmt ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fmt.chunkId = chunk.chunkId;\r\n      this.fmt.chunkSize = chunk.chunkSize;\r\n      this.fmt.audioFormat = this.readUInt16_(buffer);\r\n      this.fmt.numChannels = this.readUInt16_(buffer);\r\n      this.fmt.sampleRate = this.readUInt32(buffer);\r\n      this.fmt.byteRate = this.readUInt32(buffer);\r\n      this.fmt.blockAlign = this.readUInt16_(buffer);\r\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.readUInt16_(buffer);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\r\n          this.fmt.subformat = [\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fact');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fact.chunkId = chunk.chunkId;\r\n      this.fact.chunkSize = chunk.chunkSize;\r\n      this.fact.dwSampleLength = this.readUInt32(buffer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('cue ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.cue.chunkId = chunk.chunkId;\r\n      this.cue.chunkSize = chunk.chunkSize;\r\n      this.cue.dwCuePoints = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwPosition: this.readUInt32(buffer),\r\n          fccChunk: this.readString(buffer, 4),\r\n          dwChunkStart: this.readUInt32(buffer),\r\n          dwBlockStart: this.readUInt32(buffer),\r\n          dwSampleOffset: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('smpl');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.smpl.chunkId = chunk.chunkId;\r\n      this.smpl.chunkSize = chunk.chunkSize;\r\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\r\n      this.smpl.dwProduct = this.readUInt32(buffer);\r\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\r\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\r\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwType: this.readUInt32(buffer),\r\n          dwStart: this.readUInt32(buffer),\r\n          dwEnd: this.readUInt32(buffer),\r\n          dwFraction: this.readUInt32(buffer),\r\n          dwPlayCount: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, samples) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk.chunkSize;\r\n      if (samples) {\r\n        this.data.samples = buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end);\r\n      }\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('bext');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.bext.chunkId = chunk.chunkId;\r\n      this.bext.chunkSize = chunk.chunkSize;\r\n      this.bext.description = this.readString(buffer, 256);\r\n      this.bext.originator = this.readString(buffer, 32);\r\n      this.bext.originatorReference = this.readString(buffer, 32);\r\n      this.bext.originationDate = this.readString(buffer, 10);\r\n      this.bext.originationTime = this.readString(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.readUInt32(buffer),\r\n        this.readUInt32(buffer)];\r\n      this.bext.version = this.readUInt16_(buffer);\r\n      this.bext.UMID = this.readString(buffer, 64);\r\n      this.bext.loudnessValue = this.readUInt16_(buffer);\r\n      this.bext.loudnessRange = this.readUInt16_(buffer);\r\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\r\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\r\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\r\n      this.bext.reserved = this.readString(buffer, 180);\r\n      this.bext.codingHistory = this.readString(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readiXMLChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('iXML');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.iXML.chunkId = chunk.chunkId;\r\n      this.iXML.chunkSize = chunk.chunkSize;\r\n      this.iXML.value = unpackString(\r\n        buffer, this.head, this.head + this.iXML.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('ds64');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.ds64.chunkId = chunk.chunkId;\r\n      this.ds64.chunkSize = chunk.chunkSize;\r\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\r\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\r\n      this.ds64.originationTime = this.readUInt32(buffer);\r\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\r\n      this.ds64.sampleCountLow = this.readUInt32(buffer);\r\n      //if (wav.ds64.chunkSize > 28) {\r\n      //  wav.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  wav.ds64.table = chunkData.slice(\r\n      //     32, 32 + wav.ds64.tableLength);\r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk('LIST', true);\r\n    if (listChunks !== null) {\r\n      for (let j=0; j < listChunks.length; j++) {\r\n        /** @type {!Object} */\r\n        let subChunk = listChunks[j];\r\n        this.LIST.push({\r\n          chunkId: subChunk.chunkId,\r\n          chunkSize: subChunk.chunkSize,\r\n          format: subChunk.format,\r\n          subChunks: []});\r\n        for (let x=0; x<subChunk.subChunks.length; x++) {\r\n          this.readLISTSubChunks_(subChunk.subChunks[x],\r\n            subChunk.format, buffer);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk.chunkId) > -1) {\r\n        this.readLISTadtlSubChunks_(buffer, subChunk);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.readLISTINFOSubChunks_(buffer, subChunk);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTadtlSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    /** @type {!Object<string, string|number>} */\r\n    let item = {\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      dwName: this.readUInt32(buffer)\r\n    };\r\n    if (subChunk.chunkId == 'ltxt') {\r\n      item.dwSampleLength = this.readUInt32(buffer);\r\n      item.dwPurposeID = this.readUInt32(buffer);\r\n      item.dwCountry = this.readUInt16_(buffer);\r\n      item.dwLanguage = this.readUInt16_(buffer);\r\n      item.dwDialect = this.readUInt16_(buffer);\r\n      item.dwCodePage = this.readUInt16_(buffer);\r\n      item.value = ''; // kept for compatibility\r\n    } else {\r\n      item.value = this.readZSTR_(buffer, this.head);\r\n    }\r\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTINFOSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    this.LIST[this.LIST.length - 1].subChunks.push({\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      value: this.readZSTR_(buffer, this.head)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        chunkId: chunk.chunkId,\r\n        chunkSize: chunk.chunkSize,\r\n        chunkData: [].slice.call(buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  read_PMXChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('_PMX');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this._PMX.chunkId = chunk.chunkId;\r\n      this._PMX.chunkSize = chunk.chunkSize;\r\n      this._PMX.value = unpackString(\r\n        buffer, this.head, this.head + this._PMX.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    for (let i = index; i < bytes.length; i++) {\r\n      this.head++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n    }\r\n    return unpackString(bytes, index, this.head - 1);\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\r\n  readUInt16_(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt16, this.head);\r\n    this.head += 2;\r\n    return value;\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The writeString function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { packString } from './binary';\r\n\r\n/**\r\n * Pack a string an array of bytes. If the packed string length is smaller\r\n * than the desired byte length the output array is filled with 0s.\r\n * @param {string} str The string to be written as bytes.\r\n * @param {number} byteLength the size of the string in bytes.\r\n * @return {!Array<number>} The packed string.\r\n */\r\nexport function writeString(str, byteLength) {\r\n  /** @type {!Array<number>} */   \r\n  let packedString = packString(str);\r\n  for (let i = packedString.length; i < byteLength; i++) {\r\n    packedString.push(0);\r\n  }\r\n  return packedString;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileReader } from './wavefile-reader';\r\nimport { writeString } from './parsers/write-string';\r\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\r\nexport class WaveFileParser extends WaveFileReader {\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\r\n  toBuffer() {\r\n    this.uInt16.be = this.container === 'RIFX';\r\n    this.uInt32.be = this.uInt16.be;\r\n    /** @type {!Array<!Array<number>>} */\r\n    let fileBody = [\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getiXMLBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      packString(this.data.chunkId),\r\n      pack(this.data.samples.length, this.uInt32),\r\n      this.data.samples,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_(),\r\n      this.get_PMXBytes_()\r\n    ];\r\n    /** @type {number} */\r\n    let fileBodyLength = 0;\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      fileBodyLength += fileBody[i].length;\r\n    }\r\n    /** @type {!Uint8Array} */\r\n    let file = new Uint8Array(fileBodyLength + 12);\r\n    /** @type {number} */\r\n    let index = 0;\r\n    index = packStringTo(this.container, file, index);\r\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\r\n    index = packStringTo(this.format, file, index);\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      file.set(fileBody[i], index);\r\n      index += fileBody[i].length;\r\n    }\r\n    return file;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\r\n      bytes = bytes.concat(\r\n        packString(this.bext.chunkId),\r\n        pack(602 + this.bext.codingHistory.length, this.uInt32),\r\n        writeString(this.bext.description, 256),\r\n        writeString(this.bext.originator, 32),\r\n        writeString(this.bext.originatorReference, 32),\r\n        writeString(this.bext.originationDate, 10),\r\n        writeString(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], this.uInt32),\r\n        pack(this.bext.timeReference[1], this.uInt32),\r\n        pack(this.bext.version, this.uInt16),\r\n        writeString(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, this.uInt16),\r\n        pack(this.bext.loudnessRange, this.uInt16),\r\n        pack(this.bext.maxTruePeakLevel, this.uInt16),\r\n        pack(this.bext.maxMomentaryLoudness, this.uInt16),\r\n        pack(this.bext.maxShortTermLoudness, this.uInt16),\r\n        writeString(this.bext.reserved, 180),\r\n        writeString(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (let prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\r\n  getiXMLBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.iXML.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let iXMLPackedValue = packString(this.iXML.value);\r\n      this.iXML.chunkSize = iXMLPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this.iXML.chunkId),\r\n        pack(this.iXML.chunkSize, this.uInt32),\r\n        iXMLPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.ds64.chunkId),\r\n        pack(this.ds64.chunkSize, this.uInt32),\r\n        pack(this.ds64.riffSizeHigh, this.uInt32),\r\n        pack(this.ds64.riffSizeLow, this.uInt32),\r\n        pack(this.ds64.dataSizeHigh, this.uInt32),\r\n        pack(this.ds64.dataSizeLow, this.uInt32),\r\n        pack(this.ds64.originationTime, this.uInt32),\r\n        pack(this.ds64.sampleCountHigh, this.uInt32),\r\n        pack(this.ds64.sampleCountLow, this.uInt32));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, this.uInt32),\r\n    //    this.ds64.table);\r\n    //}\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.cue.chunkId),\r\n        pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\r\n        pack(this.cue.dwCuePoints, this.uInt32),\r\n        cuePointsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i].dwName, this.uInt32),\r\n        pack(this.cue.points[i].dwPosition, this.uInt32),\r\n        packString(this.cue.points[i].fccChunk),\r\n        pack(this.cue.points[i].dwChunkStart, this.uInt32),\r\n        pack(this.cue.points[i].dwBlockStart, this.uInt32),\r\n        pack(this.cue.points[i].dwSampleOffset, this.uInt32));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.smpl.chunkId),\r\n        pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\r\n        pack(this.smpl.dwManufacturer, this.uInt32),\r\n        pack(this.smpl.dwProduct, this.uInt32),\r\n        pack(this.smpl.dwSamplePeriod, this.uInt32),\r\n        pack(this.smpl.dwMIDIUnityNote, this.uInt32),\r\n        pack(this.smpl.dwMIDIPitchFraction, this.uInt32),\r\n        pack(this.smpl.dwSMPTEFormat, this.uInt32),\r\n        pack(this.smpl.dwSMPTEOffset, this.uInt32),\r\n        pack(this.smpl.dwNumSampleLoops, this.uInt32),\r\n        pack(this.smpl.dwSamplerData, this.uInt32),\r\n        smplLoopsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i].dwName, this.uInt32),\r\n        pack(this.smpl.loops[i].dwType, this.uInt32),\r\n        pack(this.smpl.loops[i].dwStart, this.uInt32),\r\n        pack(this.smpl.loops[i].dwEnd, this.uInt32),\r\n        pack(this.smpl.loops[i].dwFraction, this.uInt32),\r\n        pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.fact.chunkId),\r\n        pack(this.fact.chunkSize, this.uInt32),\r\n        pack(this.fact.dwSampleLength, this.uInt32));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let fmtBytes = [];\r\n    if (this.fmt.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let bytes  = fmtBytes.concat(\r\n        packString(this.fmt.chunkId),\r\n        pack(this.fmt.chunkSize, this.uInt32),\r\n        pack(this.fmt.audioFormat, this.uInt16),\r\n        pack(this.fmt.numChannels, this.uInt16),\r\n        pack(this.fmt.sampleRate, this.uInt32),\r\n        pack(this.fmt.byteRate, this.uInt32),\r\n        pack(this.fmt.blockAlign, this.uInt16),\r\n        pack(this.fmt.bitsPerSample, this.uInt16),\r\n        this.getFmtExtensionBytes_());\r\n      this.enforceByteLen_(bytes);\r\n      return bytes;\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, this.uInt32));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], this.uInt32),\r\n        pack(this.fmt.subformat[1], this.uInt32),\r\n        pack(this.fmt.subformat[2], this.uInt32),\r\n        pack(this.fmt.subformat[3], this.uInt32));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i].subChunks, this.LIST[i].format);\r\n      bytes = bytes.concat(\r\n        packString(this.LIST[i].chunkId),\r\n        pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\r\n        packString(this.LIST[i].format),\r\n        subChunksBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i = 0, len = subChunks.length; i < len; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\r\n      } else if (format == 'adtl') {\r\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\r\n      }\r\n      this.enforceByteLen_(bytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTINFOSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    /** @type {!Array<number>} */\r\n    let LISTsubChunkValue = writeString(\r\n        subChunk.value, subChunk.value.length);\r\n    bytes = bytes.concat(\r\n      packString(subChunk.chunkId),\r\n      pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\r\n      LISTsubChunkValue);\r\n    bytes.push(0);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTadtlSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\r\n      /** @type {!Array<number>} */\r\n      let LISTsubChunkValue = writeString(\r\n          subChunk.value,\r\n          subChunk.value.length);\r\n      bytes = bytes.concat(\r\n        packString(subChunk.chunkId),\r\n        pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\r\n        pack(subChunk.dwName, this.uInt32),\r\n        LISTsubChunkValue);\r\n      bytes.push(0);\r\n    } else if (subChunk.chunkId == 'ltxt') {\r\n      bytes = bytes.concat(\r\n        this.getLtxtChunkBytes_(subChunk));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      packString(ltxt.chunkId),\r\n      pack(ltxt.value.length + 20, this.uInt32),\r\n      pack(ltxt.dwName, this.uInt32),\r\n      pack(ltxt.dwSampleLength, this.uInt32),\r\n      pack(ltxt.dwPurposeID, this.uInt32),\r\n      pack(ltxt.dwCountry, this.uInt16),\r\n      pack(ltxt.dwLanguage, this.uInt16),\r\n      pack(ltxt.dwDialect, this.uInt16),\r\n      pack(ltxt.dwCodePage, this.uInt16),\r\n       // should always be a empty string;\r\n       // kept for compatibility\r\n      writeString(ltxt.value, ltxt.value.length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\r\n  get_PMXBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this._PMX.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let _PMXPackedValue = packString(this._PMX.value);\r\n      this._PMX.chunkSize = _PMXPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this._PMX.chunkId),\r\n        pack(this._PMX.chunkSize, this.uInt32),\r\n        _PMXPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        packString(this.junk.chunkId),\r\n        pack(this.junk.chunkData.length, this.uInt32), //chunkSize\r\n        this.junk.chunkData);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\r\n  enforceByteLen_(bytes) {\r\n    if (bytes.length % 2) {\r\n      bytes.push(0);\r\n    }\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The interleave function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * Interleave de-interleaved samples.\r\n * @param {!(Array|TypedArray)} samples The samples.\r\n * @return {!(Array|TypedArray)}\r\n */\r\nexport function interleave(samples) {\r\n  /** @type {!(Array|TypedArray)} */\r\n  let finalSamples = [];\r\n  if (samples.length > 0) {\r\n    if (samples[0].constructor !== Number) {\r\n      finalSamples = new Float64Array(samples[0].length * samples.length);\r\n      for (let i = 0, len = samples[0].length, x = 0; i < len; i++) {\r\n        for (let j = 0, subLen = samples.length; j < subLen; j++, x++) {\r\n          finalSamples[x] = samples[j][i];\r\n        }\r\n      }\r\n    } else {\r\n      finalSamples = samples;\r\n    }\r\n  }\r\n  return finalSamples;\r\n}\r\n\r\n/**\r\n * De-interleave samples into multiple channels.\r\n * @param {!(Array|TypedArray)} samples The samples.\r\n * @param {number} numChannels The number of channels to split the samples.\r\n * @param {Function} [OutputObject=Float64Array] The type of object to\r\n *   write the de-interleaved samples.\r\n * @return {!(Array|TypedArray)}\r\n */\r\nexport function deInterleave(samples, numChannels, OutputObject=Float64Array) {\r\n  /** @type {!(Array|TypedArray)} */\r\n  let finalSamples = [];\r\n  for (let i = 0; i < numChannels; i++) {\r\n    finalSamples[i] = new OutputObject(samples.length / numChannels);\r\n  }\r\n  for (let i = 0; i < numChannels; i++) {\r\n    for (let j = i, s = 0; j < samples.length; j+= numChannels, s++) {\r\n      finalSamples[i][s] = samples[j];\r\n    }\r\n  }\r\n  return finalSamples;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The validateNumChannels function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * Validate the number of channels in a wav file according to the\r\n * bit depth of the audio.\r\n * @param {number} channels The number of channels in the file.\r\n * @param {number} bits The number of bits per sample.\r\n * @return {boolean} True is the number of channels is valid.\r\n */\r\nexport function validateNumChannels(channels, bits) {\r\n  /** @type {number} */\r\n  let blockAlign = channels * bits / 8;\r\n  if (channels < 1 || blockAlign > 65535) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The validateSampleRate function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * Validate the sample rate value of a wav file according to the number of\r\n * channels and the bit depth of the audio.\r\n * @param {number} channels The number of channels in the file.\r\n * @param {number} bits The number of bits per sample.\r\n * @param {number} sampleRate The sample rate to be validated.\r\n * @return {boolean} True is the sample rate is valid, false otherwise.\r\n */\r\nexport function validateSampleRate(channels, bits, sampleRate) {\r\n  /** @type {number} */\r\n  let byteRate = channels * (bits / 8) * sampleRate;\r\n  if (sampleRate < 1 || byteRate > 4294967295) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileParser } from './wavefile-parser';\r\nimport { interleave, deInterleave } from './parsers/interleave';\r\nimport { validateNumChannels } from './validators/validate-num-channels'; \r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\r\nexport class WaveFileCreator extends WaveFileParser {\r\n\r\n  constructor() {\r\n    super();\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.dataType = {bits: 0, be: false};\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\r\n    this.WAV_AUDIO_FORMATS = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    options = options || {};\r\n    // reset all chunks\r\n    this.clearHeaders();\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    super.fromBuffer(wavBuffer, samples);\r\n    this.bitDepthFromFmt_();\r\n    this.updateDataType_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\r\n  toBuffer() {\r\n    this.validateWavHeader_();\r\n    return super.toBuffer();\r\n  }\r\n\r\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\r\n  getSamples(interleaved=false, OutputObject=Float64Array) {\r\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = new OutputObject(\r\n      this.data.samples.length / (this.dataType.bits / 8));\r\n    // Unpack all the samples\r\n    unpackArrayTo(this.data.samples, this.dataType, samples,\r\n      0, this.data.samples.length);\r\n    if (!interleaved && this.fmt.numChannels > 1) {\r\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\r\n    }\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  getSample(index) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    return unpack(\r\n      this.data.samples.slice(index, index + this.dataType.bits / 8),\r\n      this.dataType);\r\n  }\r\n\r\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  setSample(index, sample) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    packTo(sample, this.dataType, this.data.samples, index, true);\r\n  }\r\n\r\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\r\n  getiXML() {\r\n    return this.iXML.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  setiXML(iXMLValue) {\r\n    if (typeof iXMLValue !== 'string') {\r\n      throw new TypeError('iXML value must be a string.');\r\n    }\r\n    this.iXML.value = iXMLValue;\r\n    this.iXML.chunkId = 'iXML';\r\n  }\r\n\r\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\r\n  get_PMX() {\r\n    return this._PMX.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  set_PMX(_PMXValue) {\r\n    if (typeof _PMXValue !== 'string') {\r\n      throw new TypeError('_PMX value must be a string.');\r\n    }\r\n    this._PMX.value = _PMXValue;\r\n    this._PMX.chunkId = '_PMX';\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    if (!options.container) {\r\n      options.container = 'RIFF';\r\n    }\r\n    this.container = options.container;\r\n    this.bitDepth = bitDepthCode;\r\n    samples = interleave(samples);\r\n    this.updateDataType_();\r\n    /** @type {number} */\r\n    let numBytes = this.dataType.bits / 8;\r\n    this.data.samples = new Uint8Array(samples.length * numBytes);\r\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\r\n    this.makeWavHeader_(\r\n      bitDepthCode, numChannels, sampleRate,\r\n      numBytes, this.data.samples.length, options);\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length;\r\n    this.validateWavHeader_();\r\n  }\r\n\r\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  makeWavHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    if (bitDepthCode == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if(Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 ||\r\n        numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else {\r\n      this.createPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);      \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.container = options.container;\r\n    this.chunkSize = 36 + samplesLength;\r\n    this.format = 'WAVE';\r\n    this.bitDepth = bitDepthCode;\r\n    this.fmt = {\r\n      chunkId: 'fmt ',\r\n      chunkSize: 16,\r\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\r\n      numChannels: numChannels,\r\n      sampleRate: sampleRate,\r\n      byteRate: (numChannels * numBytes) * sampleRate,\r\n      blockAlign: numChannels * numBytes,\r\n      bitsPerSample: parseInt(bitDepthCode, 10),\r\n      cbSize: 0,\r\n      validBitsPerSample: 0,\r\n      dwChannelMask: 0,\r\n      subformat: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength * 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 36 + 24 + samplesLength;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepthCode, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\r\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels);\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat === 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat === 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\r\n  updateDataType_() {\r\n    this.dataType = {\r\n      bits: ((parseInt(this.bitDepth, 10) - 1) | 7) + 1,\r\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\r\n      signed: this.bitDepth != '8',\r\n      be: this.container == 'RIFX'\r\n    };\r\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1 ) {\r\n      this.dataType.bits = 8;\r\n      this.dataType.signed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\r\n  validateWavHeader_() {\r\n    this.validateBitDepth_();\r\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\r\nfunction dwChannelMask_(numChannels) {\r\n  /** @type {number} */\r\n  let mask = 0;\r\n  // mono = FC\r\n  if (numChannels === 1) {\r\n    mask = 0x4;\r\n  // stereo = FL, FR\r\n  } else if (numChannels === 2) {\r\n    mask = 0x3;\r\n  // quad = FL, FR, BL, BR\r\n  } else if (numChannels === 4) {\r\n    mask = 0x33;\r\n  // 5.1 = FL, FR, FC, LF, BL, BR\r\n  } else if (numChannels === 6) {\r\n    mask = 0x3F;\r\n  // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n  } else if (numChannels === 8) {\r\n    mask = 0x63F;\r\n  }\r\n  return mask;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileTagEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileCreator } from './wavefile-creator';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileCreator\r\n * @ignore\r\n */\r\nexport class WaveFileTagEditor extends WaveFileCreator {\r\n\r\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   */\r\n  getTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      return this.LIST[index.LIST].subChunks[index.TAG].value;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   */\r\n  setTag(tag, value) {\r\n    tag = fixRIFFTag_(tag);\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks[index.TAG].chunkSize =\r\n        value.length + 1;\r\n      this.LIST[index.LIST].subChunks[index.TAG].value = value;\r\n    } else if (index.LIST !== null) {\r\n      this.LIST[index.LIST].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    } else {\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 8 + value.length + 1,\r\n        format: 'INFO',\r\n        subChunks: []});\r\n      this.LIST[this.LIST.length - 1].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a RIFF tag from the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   */\r\n  deleteTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks.splice(index.TAG, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return a Object<tag, value> with the RIFF tags in the file.\r\n   * @return {!Object<string, string>} The file tags.\r\n   */\r\n  listTags() {\r\n    /** @type {?number} */\r\n    let index = this.getLISTIndex('INFO');\r\n    /** @type {!Object} */\r\n    let tags = {};\r\n    if (index !== null) {\r\n      for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n        tags[this.LIST[index].subChunks[i].chunkId] =\r\n          this.LIST[index].subChunks[i].value;\r\n      }\r\n    }\r\n    return tags;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a list by its type.\r\n   * @param {string} listType The list type ('adtl', 'INFO')\r\n   * @return {?number}\r\n   * @protected\r\n   */\r\n  getLISTIndex(listType) {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == listType) {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\r\n  getTagIndex_(tag) {\r\n    /** @type {!Object<string, ?number>} */\r\n    let index = {LIST: null, TAG: null};\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'INFO') {\r\n        index.LIST = i;\r\n        for (let j=0, subLen = this.LIST[i].subChunks.length; j < subLen; j++) {\r\n          if (this.LIST[i].subChunks[j].chunkId == tag) {\r\n            index.TAG = j;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n}\r\n\r\n/**\r\n * Fix a RIFF tag format if possible, throw an error otherwise.\r\n * @param {string} tag The tag name.\r\n * @return {string} The tag name in proper fourCC format.\r\n * @private\r\n */\r\nfunction fixRIFFTag_(tag) {\r\n  if (tag.constructor !== String) {\r\n    throw new Error('Invalid tag name.');\r\n  } else if (tag.length < 4) {\r\n    for (let i = 0, len = 4 - tag.length; i < len; i++) {\r\n      tag += ' ';\r\n    }\r\n  }\r\n  return tag;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\r\nexport class WaveFileCueEditor extends WaveFileTagEditor {\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\r\n  listCuePoints() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = this.getCuePoints_();\r\n    for (let i = 0, len = points.length; i < len; i++) {\r\n\r\n      // Add attrs that should exist in the object\r\n      points[i].position =\r\n        (points[i].dwSampleOffset / this.fmt.sampleRate) * 1000;\r\n\r\n      // If it is a region, calc the end\r\n      // position in milliseconds\r\n      if (points[i].dwSampleLength) {\r\n        points[i].end =\r\n          (points[i].dwSampleLength / this.fmt.sampleRate) * 1000;\r\n        points[i].end += points[i].position;\r\n      // If its not a region, end should be null\r\n      } else {\r\n        points[i].end = null;\r\n      }\r\n\r\n      // Remove attrs that should not go in the results\r\n      delete points[i].value;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\r\n  setCuePoint(pointData) {\r\n    this.cue.chunkId = 'cue ';\r\n\r\n    // label attr should always exist\r\n    if (!pointData.label) {\r\n      pointData.label = '';\r\n    }\r\n\r\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\r\n    let existingPoints = this.getCuePoints_();\r\n\r\n    // Clear any LIST labeled 'adtl'\r\n    // The LIST chunk should be re-written\r\n    // after the new cue point is created\r\n    this.clearLISTadtl_();\r\n\r\n    // Erase this.cue so it can be re-written\r\n    // after the point is added\r\n    this.cue.points = [];\r\n\r\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleOffset =\r\n      (pointData.position * this.fmt.sampleRate) / 1000;\r\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleLength = 0;\r\n    if (pointData.end) {\r\n      pointData.dwSampleLength = \r\n        ((pointData.end * this.fmt.sampleRate) / 1000) -\r\n        pointData.dwSampleOffset;\r\n    }\r\n\r\n    // If there were no cue points in the file,\r\n    // insert the new cue point as the first\r\n    if (existingPoints.length === 0) {\r\n      this.setCuePoint_(pointData, 1);\r\n\r\n    // If the file already had cue points, This new one\r\n    // must be added in the list according to its position.\r\n    } else {\r\n      this.setCuePointInOrder_(existingPoints, pointData);\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (i + 1 !== index) {\r\n        this.setCuePoint_(existingPoints[i], i + 1);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let cIndex = this.getLISTIndex('adtl');\r\n    if (cIndex !== null) {\r\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\r\n        if (this.LIST[cIndex].subChunks[i].dwName ==\r\n            pointIndex) {\r\n          this.LIST[cIndex].subChunks[i].value = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i = 0; i < this.cue.points.length; i++) {\r\n      /** @type {!Object} */\r\n      let chunk = this.cue.points[i];\r\n      /** @type {!Object} */\r\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\r\n      pointData.label = pointData.value ? pointData.value : '';\r\n      pointData.dwPosition = chunk.dwPosition;\r\n      pointData.fccChunk = chunk.fccChunk;\r\n      pointData.dwChunkStart = chunk.dwChunkStart;\r\n      pointData.dwBlockStart = chunk.dwBlockStart;\r\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\r\n      points.push(pointData);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\r\n  getDataForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let LISTindex = this.getLISTIndex('adtl');\r\n    /** @type {!Object} */\r\n    let pointData = {};\r\n    // If there is a adtl LIST in the file, look for\r\n    // LIST subchunks with data referencing this point\r\n    if (LISTindex !== null) {\r\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\r\n    }\r\n    return pointData;\r\n  }\r\n\r\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  getCueDataFromLIST_(pointData, index, pointDwName) {\r\n    // got through all chunks in the adtl LIST checking\r\n    // for references to this cue point\r\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\r\n        /** @type {!Object} */\r\n        let chunk = this.LIST[index].subChunks[i];\r\n        // Some chunks may reference the point but\r\n        // have a empty text; this is to ensure that if\r\n        // one chunk that reference the point has a text,\r\n        // this value will be kept as the associated data label\r\n        // for the cue point.\r\n        // If different values are present, the last value found\r\n        // will be considered the label for the cue point.\r\n        pointData.value = chunk.value || pointData.value;\r\n        pointData.dwName = chunk.dwName || 0;\r\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\r\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\r\n        pointData.dwCountry = chunk.dwCountry || 0;\r\n        pointData.dwLanguage = chunk.dwLanguage || 0;\r\n        pointData.dwDialect = chunk.dwDialect || 0;\r\n        pointData.dwCodePage = chunk.dwCodePage || 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(pointData, dwName) {\r\n    this.cue.points.push({\r\n      dwName: dwName,\r\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\r\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\r\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\r\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\r\n      dwSampleOffset: pointData.dwSampleOffset\r\n    });\r\n    this.setLabl_(pointData, dwName);\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\r\n  setCuePointInOrder_(existingPoints, pointData) {\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n\r\n    // Iterate over the cue points that existed\r\n    // before this one was added\r\n    for (let i = 0; i < existingPoints.length; i++) {\r\n\r\n      // If the new point is located before this original point\r\n      // and the new point have not been created, create the\r\n      // new point and then the original point\r\n      if (existingPoints[i].dwSampleOffset > \r\n        pointData.dwSampleOffset && !hasSet) {\r\n        // create the new point\r\n        this.setCuePoint_(pointData, i + 1);\r\n\r\n        // create the original point\r\n        this.setCuePoint_(existingPoints[i], i + 2);\r\n        hasSet = true;\r\n\r\n      // Otherwise, re-create the original point\r\n      } else {\r\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\r\n      }\r\n    }\r\n    // If no point was created in the above loop,\r\n    // create the new point as the last one\r\n    if (!hasSet) {\r\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(pointData, dwName) {\r\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\r\n    let adtlIndex = this.getLISTIndex('adtl');\r\n    // If there is no adtl LIST, create one\r\n    if (adtlIndex === null) {\r\n      // Include a new item LIST chunk\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 4,\r\n        format: 'adtl',\r\n        subChunks: []});\r\n      // Get the index of the new LIST chunk\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex, pointData, dwName);\r\n    if (pointData.dwSampleLength) {\r\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'labl',\r\n      chunkSize: 4, // should be 4 + label length in bytes\r\n      dwName: dwName,\r\n      value: pointData.label\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\r\n  }\r\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'ltxt',\r\n      chunkSize: 20,  // should be 12 + label byte length\r\n      dwName: dwName,\r\n      dwSampleLength: pointData.dwSampleLength,\r\n      dwPurposeID: pointData.dwPurposeID || 0,\r\n      dwCountry: pointData.dwCountry || 0,\r\n      dwLanguage: pointData.dwLanguage || 0,\r\n      dwDialect: pointData.dwDialect || 0,\r\n      dwCodePage: pointData.dwCodePage || 0,\r\n      value: pointData.label // kept for compatibility\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 28;\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright 2012 Spencer Cohen\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The Interpolator class. Based on Smooth.js by Spencer Cohen.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/osuushi/Smooth.js\r\n */\r\n\r\n/**\r\n * A class to get scaled values out of arrays.\r\n * @extends WaveFileReader\r\n */\r\nexport class Interpolator {\r\n  \r\n  /**\r\n   * @param {number} scaleFrom the length of the original array.\r\n   * @param {number} scaleTo The length of the new array.\r\n   * @param {!Object} details The extra configuration, if needed.\r\n   */\r\n  constructor(scaleFrom, scaleTo, details) {\r\n    /**\r\n     * The length of the original array.\r\n     * @type {number}\r\n     */\r\n    this.length_ = scaleFrom;\r\n    /**\r\n     * The scaling factor.\r\n     * @type {number}\r\n     */\r\n    this.scaleFactor_ = (scaleFrom - 1) / scaleTo;\r\n    /**\r\n     * The interpolation function.\r\n     * @type {Function}\r\n     */\r\n    this.interpolate = this.sinc;\r\n    if (details.method === 'point') {\r\n    \tthis.interpolate = this.point;\r\n    } else if(details.method === 'linear') {\r\n    \tthis.interpolate = this.linear;\r\n    } else if(details.method === 'cubic') {\r\n    \tthis.interpolate = this.cubic;\r\n    }\r\n    /**\r\n     * The tanget factor for cubic interpolation.\r\n     * @type {number}\r\n     */\r\n    this.tangentFactor_ = 1 - Math.max(0, Math.min(1, details.tension || 0));\r\n    // Configure the kernel for sinc\r\n    /**\r\n     * The sinc filter size.\r\n     * @type {number}\r\n     */\r\n    this.sincFilterSize_ = details.sincFilterSize || 1;\r\n    /**\r\n     * The sinc kernel.\r\n     * @type {Function}\r\n     */\r\n    this.kernel_ = sincKernel_(details.sincWindow || window_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  point(t, samples) {\r\n    return this.getClippedInput_(Math.round(this.scaleFactor_ * t), samples);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  linear(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    /** @type {number} */\r\n    let k = Math.floor(t);\r\n    t -= k;\r\n    return (1 - t) *\r\n    \tthis.getClippedInput_(k, samples) + t *\r\n    \tthis.getClippedInput_(k + 1, samples);\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  cubic(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    /** @type {number} */\r\n    let k = Math.floor(t);\r\n    /** @type {Array<number>} */\r\n    let m = [this.getTangent_(k, samples), this.getTangent_(k + 1, samples)];\r\n    /** @type {Array<number>} */\r\n    let p = [this.getClippedInput_(k, samples),\r\n      this.getClippedInput_(k + 1, samples)];\r\n    t -= k;\r\n    /** @type {number} */\r\n    let t2 = t * t;\r\n    /** @type {number} */\r\n    let t3 = t * t2;\r\n    return (2 * t3 - 3 * t2 + 1) *\r\n      p[0] + (t3 - 2 * t2 + t) *\r\n      m[0] + (-2 * t3 + 3 * t2) *\r\n      p[1] + (t3 - t2) * m[1];\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   */\r\n  sinc(t, samples) {\r\n    t = this.scaleFactor_ * t;\r\n    /** @type {number} */\r\n    let k = Math.floor(t);\r\n    /** @type {number} */\r\n    let ref = k - this.sincFilterSize_ + 1;\r\n    /** @type {number} */\r\n    let ref1 = k + this.sincFilterSize_;\r\n    /** @type {number} */\r\n    let sum = 0;\r\n    for (let n = ref; n <= ref1; n++) {\r\n      sum += this.kernel_(t - n) * this.getClippedInput_(n, samples);\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * @param {number} k The scaled index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The tangent.\r\n   * @private\r\n   */\r\n  getTangent_(k, samples) {\r\n    return this.tangentFactor_ *\r\n      (this.getClippedInput_(k + 1, samples) -\r\n        this.getClippedInput_(k - 1, samples)) / 2;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t The scaled index to interpolate.\r\n   * @param {Array<number>|TypedArray} samples the original array.\r\n   * @return {number} The interpolated value.\r\n   * @private\r\n   */\r\n  getClippedInput_(t, samples) {\r\n    if ((0 <= t && t < this.length_)) {\r\n      return samples[t];\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * The default window function.\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction window_(x) {\r\n  return Math.exp(-x / 2 * x / 2);\r\n}\r\n\r\n/**\r\n * @param {Function} window The window function.\r\n * @return {Function}\r\n * @private\r\n */\r\nfunction sincKernel_(window) {\r\n  return function(x) { return sinc_(x) * window(x); };\r\n}\r\n\r\n/**\r\n * @param {number} x The sinc signal.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sinc_(x) {\r\n  if (x === 0) {\r\n    return 1;\r\n  }\r\n  return Math.sin(Math.PI * x) / (Math.PI * x);\r\n}\r\n", "/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview FIR LPF. Based on the FIR LPF from Fili by Florian Markert.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/markert/fili.js\r\n */\r\n\r\n/**\r\n * A FIR low pass filter.\r\n */\r\nexport class FIRLPF {\r\n  \r\n  /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */\r\n  constructor(order, sampleRate, cutOff) {\r\n    /** @type {number} */\r\n    let omega = 2 * Math.PI * cutOff / sampleRate;\r\n    /** @type {number} */\r\n    let dc = 0;\r\n    this.filters = [];\r\n    for (let i = 0; i <= order; i++) {\r\n      if (i - order / 2 === 0) {\r\n        this.filters[i] = omega;\r\n      } else {\r\n        this.filters[i] = Math.sin(omega * (i - order / 2)) / (i - order / 2);\r\n        // Hamming window\r\n        this.filters[i] *= (0.54 - 0.46 * Math.cos(2 * Math.PI * i / order));\r\n      }\r\n      dc = dc + this.filters[i];\r\n    }\r\n    // normalize\r\n    for (let i = 0; i <= order; i++) {\r\n      this.filters[i] /= dc;\r\n    }\r\n    this.z = this.initZ_();\r\n  }\r\n\r\n  /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */\r\n  filter(sample) {\r\n    this.z.buf[this.z.pointer] = sample;\r\n    /** @type {number} */\r\n    let out = 0;\r\n    for (let i = 0, len = this.z.buf.length; i < len; i++) {\r\n      out += (\r\n        this.filters[i] * this.z.buf[(this.z.pointer + i) % this.z.buf.length]);\r\n    }\r\n    this.z.pointer = (this.z.pointer + 1) % (this.z.buf.length);\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Reset the filter.\r\n   */\r\n  reset() {\r\n    this.z = this.initZ_();\r\n  }\r\n\r\n  /**\r\n   * Return the default value for z.\r\n   * @private\r\n   */\r\n  initZ_() {\r\n    /** @type {!Array} */\r\n    let r = [];\r\n    for (let i = 0; i < this.filters.length - 1; i++) {\r\n      r.push(0);\r\n    }\r\n    return {\r\n      buf: r,\r\n      pointer: 0\r\n    };\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2014 Florian Markert\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Butterworth LPF. Based on the Butterworth LPF from Fili.js.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/markert/fili.js\r\n */\r\n\r\n/**\r\n * Butterworth LPF.\r\n */\r\nexport class ButterworthLPF {\r\n  \r\n  /**\r\n   * @param {number} order The order of the filter.\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} cutOff The cut off frequency.\r\n   */\r\n  constructor(order, sampleRate, cutOff) {\r\n    /** @type {!Array} */\r\n    let filters = [];\r\n    for (let i = 0; i < order; i++) {\r\n      filters.push(this.getCoeffs_({\r\n        Fs: sampleRate,\r\n        Fc: cutOff,\r\n        Q: 0.5 / (Math.sin((Math.PI / (order * 2)) * (i + 0.5)))\r\n      }));\r\n    }\r\n    this.stages = [];\r\n    for (let i = 0; i < filters.length; i++) {\r\n      this.stages[i] = {\r\n        b0 : filters[i].b[0],\r\n        b1 : filters[i].b[1],\r\n        b2 : filters[i].b[2],\r\n        a1 : filters[i].a[0],\r\n        a2 : filters[i].a[1],\r\n        k : filters[i].k,\r\n        z : [0, 0]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} sample A sample of a sequence.\r\n   * @return {number}\r\n   */\r\n  filter(sample) {\r\n    /** @type {number} */\r\n    let out = sample;\r\n    for (let i = 0, len = this.stages.length; i < len; i++) {\r\n      out = this.runStage_(i, out);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * @param {!Object} params The filter params.\r\n   * @return {!Object}\r\n   */\r\n  getCoeffs_(params) {\r\n    /** @type {!Object} */\r\n    let coeffs = {};\r\n    coeffs.a = [];\r\n    coeffs.b = [];\r\n    /** @type {!Object} */\r\n    let p = this.preCalc_(params, coeffs);\r\n    coeffs.k = 1;\r\n    coeffs.b.push((1 - p.cw) / (2 * p.a0));\r\n    coeffs.b.push(2 * coeffs.b[0]);\r\n    coeffs.b.push(coeffs.b[0]);\r\n    return coeffs;\r\n  }\r\n\r\n  /**\r\n   * @param {!Object} params The filter params.\r\n   * @param {!Object} coeffs The coefficients template.\r\n   * @return {!Object}\r\n   */\r\n  preCalc_(params, coeffs) {\r\n    /** @type {!Object} */\r\n    let pre = {};\r\n    /** @type {number} */\r\n    let w = 2 * Math.PI * params.Fc / params.Fs;\r\n    pre.alpha = Math.sin(w) / (2 * params.Q);\r\n    pre.cw = Math.cos(w);\r\n    pre.a0 = 1 + pre.alpha;\r\n    coeffs.a0 = pre.a0;\r\n    coeffs.a.push((-2 * pre.cw) / pre.a0);\r\n    coeffs.k = 1;\r\n    coeffs.a.push((1 - pre.alpha) / pre.a0);\r\n    return pre;\r\n  }\r\n  \r\n  /**\r\n   * @param {number} i The stage index.\r\n   * @param {number} sample The sample.\r\n   * @return {number}\r\n   */\r\n  runStage_(i, sample) {\r\n    /** @type {number} */\r\n    let temp = sample * this.stages[i].k - this.stages[i].a1 *\r\n      this.stages[i].z[0] - this.stages[i].a2 * this.stages[i].z[1];\r\n    /** @type {number} */\r\n    let out = this.stages[i].b0 * temp + this.stages[i].b1 *\r\n      this.stages[i].z[0] + this.stages[i].b2 * this.stages[i].z[1];\r\n    this.stages[i].z[1] = this.stages[i].z[0];\r\n    this.stages[i].z[0] = temp;\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Reset the filter.\r\n   */\r\n  reset() {\r\n    for (let i = 0; i < this.stages.length; i++) {\r\n      this.stages[i].z = [0, 0];\r\n    }\r\n  }\r\n}\r\n", "/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The resample function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { Interpolator } from './interpolator';\r\nimport { FIRLPF } from './fir-lpf';\r\nimport { ButterworthLPF } from './butterworth-lpf';\r\n\r\n/**\r\n * Default use of LPF for each resampling method.\r\n * @readonly\r\n * @enum {boolean}\r\n * @private\r\n */\r\nconst DEFAULT_LPF_USE = {\r\n  'point': false,\r\n  'linear': false,\r\n  'cubic': true,\r\n  'sinc': true\r\n};\r\n\r\n/**\r\n * Default LPF order for each type of LPF.\r\n * @readonly\r\n * @enum {number}\r\n * @private\r\n */\r\nconst DEFAULT_LPF_ORDER = {\r\n  'IIR': 16,\r\n  'FIR': 71\r\n};\r\n\r\n/**\r\n * Default LPF class for each type of LPF.\r\n * @readonly\r\n * @enum {!Function}\r\n * @private\r\n */\r\nconst DEFAULT_LPF = {\r\n  'IIR': ButterworthLPF,\r\n  'FIR': FIRLPF\r\n};\r\n\r\n/**\r\n * Change the sample rate of the samples to a new sample rate.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {number} oldSampleRate The original sample rate.\r\n * @param {number} sampleRate The target sample rate.\r\n * @param {Object=} options The extra configuration, if needed.\r\n * @return {!Float64Array} the new samples.\r\n */\r\nexport function resample(samples, oldSampleRate, sampleRate, options=null) {\r\n  options = options || {};\r\n  // Make the new sample container\r\n  /** @type {number} */\r\n  let rate = ((sampleRate - oldSampleRate) / oldSampleRate) + 1;\r\n  /** @type {!Float64Array} */\r\n  let newSamples = new Float64Array(samples.length * (rate));\r\n  // Create the interpolator\r\n  options.method = options.method || 'cubic';\r\n  /** @type {!Object} */\r\n  let interpolator = new Interpolator(\r\n    samples.length,\r\n    newSamples.length,\r\n    {\r\n      method: options.method,\r\n      tension: options.tension || 0,\r\n      sincFilterSize: options.sincFilterSize || 6,\r\n      sincWindow: options.sincWindow || undefined,\r\n      clip: options.clip || 'mirror'\r\n    });\r\n  // Resample + LPF\r\n  if (options.LPF === undefined) {\r\n    options.LPF = DEFAULT_LPF_USE[options.method];\r\n  } \r\n  if (options.LPF) {\r\n    options.LPFType = options.LPFType || 'IIR';\r\n    const LPF = DEFAULT_LPF[options.LPFType];\r\n    // Upsampling\r\n    if (sampleRate > oldSampleRate) {\r\n      /** @type {!Object} */\r\n      let filter = new LPF(\r\n        options.LPForder || DEFAULT_LPF_ORDER[options.LPFType],\r\n        sampleRate,\r\n        (oldSampleRate / 2));\r\n      upsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    // Downsampling\r\n    } else {\r\n      /** @type {!Object} */\r\n      let filter = new LPF(\r\n        options.LPForder || DEFAULT_LPF_ORDER[options.LPFType],\r\n        oldSampleRate,\r\n        sampleRate / 2);\r\n      downsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    }\r\n  // Resample, no LPF\r\n  } else {\r\n    resample_(samples, newSamples, interpolator);\r\n  }\r\n  return newSamples;\r\n}\r\n\r\n/**\r\n * Resample.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @private\r\n */\r\nfunction resample_(samples, newSamples, interpolator) {\r\n  // Resample\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = interpolator.interpolate(i, samples);\r\n  }\r\n}\r\n\r\n/**\r\n * Upsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction upsample_(samples, newSamples, interpolator, filter) {\r\n  // Resample and filter\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = filter.filter(interpolator.interpolate(i, samples));\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = newSamples.length - 1; i >= 0; i--) {\r\n    newSamples[i]  = filter.filter(newSamples[i]);\r\n  }\r\n}\r\n\r\n/**\r\n * Downsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction downsample_(samples, newSamples, interpolator, filter) {\r\n  // Filter\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = samples.length - 1; i >= 0; i--) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Resample\r\n  resample_(samples, newSamples, interpolator);\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { changeBitDepth } from './codecs/bitdepth';\r\nimport * as imaadpcm from './codecs/imaadpcm';\r\nimport * as alaw from './codecs/alaw';\r\nimport * as mulaw from './codecs/mulaw';\r\nimport { unpackArrayTo } from './parsers/binary';\r\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { resample } from './resampler';\r\n\r\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\r\nexport class WaveFileConverter extends WaveFileCueEditor {\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   */\r\n  toRIFF() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFF'});\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   */\r\n  toRIFX() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFX'});\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate !== 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if (this.fmt.numChannels !== 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      /** @type {!Int16Array} */\r\n      let output = new Int16Array(\r\n        outputSize_(this.data.samples.length, 2));\r\n      unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n      this.fromExisting_(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        imaadpcm.encode(output),\r\n        {container: this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromIMAADPCM(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      imaadpcm.decode(this.data.samples, this.fmt.blockAlign),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromALaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      mulaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromMuLaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      mulaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\r\n  toBitDepth(newBitDepth, changeResolution=true) {\r\n    /** @type {string} */\r\n    let toBitDepth = newBitDepth;\r\n    /** @type {string} */\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      if (newBitDepth != '32f') {\r\n        toBitDepth = this.dataType.bits.toString();\r\n      }\r\n      thisBitDepth = '' + this.dataType.bits;\r\n    }\r\n    // If the file is compressed, make it\r\n    // PCM before changing the bit depth\r\n    this.assureUncompressed_();\r\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = this.getSamples(true);\r\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\r\n    let newSamples = new Float64Array(samples.length);\r\n    // Change the bit depth\r\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth);\r\n    // Re-create the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      newBitDepth,\r\n      newSamples,\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\r\n  toSampleRate(sampleRate, options) {\r\n    this.validateResample_(sampleRate);\r\n    /** @type {!(Array|TypedArray)} */\r\n    let samples = this.getSamples();\r\n    /** @type {!(Array|Float64Array)} */\r\n    let newSamples = [];\r\n    // Mono files\r\n    if (samples.constructor === Float64Array) {\r\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options);\r\n    // Multi-channel files\r\n    } else {\r\n      for (let i = 0; i < samples.length; i++) {\r\n        newSamples.push(resample(\r\n          samples[i], this.fmt.sampleRate, sampleRate, options));\r\n      }\r\n    }\r\n    // Recreate the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels, sampleRate, this.bitDepth, newSamples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\r\n  validateResample_(sampleRate) {\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    } else if (['4','8a','8m'].indexOf(this.bitDepth) > -1) {\r\n      throw new Error(\r\n        'wavefile can\\'t change the sample rate of compressed files.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if (this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileCueEditor();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction outputSize_(byteLen, byteOffset) {\r\n  /** @type {number} */\r\n  let outputSize = byteLen / byteOffset;\r\n  if (outputSize % 2) {\r\n    outputSize++;\r\n  }\r\n  return outputSize;\r\n}\r\n", "/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/** @module wavefile */\r\n\r\nimport { encode, decode } from './lib/parsers/base64-arraybuffer.js';\r\nimport { WaveFileConverter } from './lib/wavefile-converter';\r\n\r\n/**\r\n * A class to manipulate wav files.\r\n * @extends WaveFileConverter\r\n */\r\nexport class WaveFile extends WaveFileConverter {\r\n\r\n  /**\r\n   * @param {Uint8Array=} wav A wave file buffer.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  constructor(wav) {\r\n    super();\r\n    if (wav) {\r\n      this.fromBuffer(wav);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a base64 string to load the WaveFile object.\r\n   * @param {string} base64String A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   */\r\n  fromBase64(base64String) {\r\n    this.fromBuffer(decode(base64String));\r\n  }\r\n\r\n  /**\r\n   * Return a base64 string representig the WaveFile object as a .wav file.\r\n   * @return {string} A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   */\r\n  toBase64() {\r\n    return encode(this.toBuffer());\r\n  }\r\n\r\n  /**\r\n   * Return a DataURI string representig the WaveFile object as a .wav file.\r\n   * The return of this method can be used to load the audio in browsers.\r\n   * @return {string} A .wav file as a DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   */\r\n  toDataURI() {\r\n    return 'data:audio/wav;base64,' + this.toBase64();\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a DataURI to load the WaveFile object.\r\n   * @param {string} dataURI A .wav file as DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   */\r\n  fromDataURI(dataURI) {\r\n    this.fromBase64(dataURI.replace('data:audio/wav;base64,', ''));\r\n  }\r\n}\r\n"],
  "mappings": "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SAAO;AACT;;;ACzRA,IAAM,YAAY;AAAA,EAChB;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9D;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9D;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9D;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAChE;AAOO,SAAS,aAAa,QAAQ;AAEnC,MAAI;AACJ,WAAU,UAAS,SAAU,SAAS;AAEtC,MAAI,OAAS,CAAC,UAAW,IAAK;AAC9B,MAAI,CAAC,MAAM;AACT,aAAS,SAAS;AAAA,EACpB;AACA,MAAI,SAAS,OAAO;AAClB,aAAS;AAAA,EACX;AACA,MAAI,UAAU,KAAM;AAElB,QAAI,WAAW,UAAW,UAAU,IAAK,GAAI;AAE7C,QAAI,WAAY,UAAW,WAAW,IAAO;AAC7C,qBAAmB,YAAY,IAAK;AAAA,EACtC,OAAO;AACL,qBAAiB,UAAU;AAAA,EAC7B;AACA,SAAO,kBAAkB,OAAO;AAClC;AAOO,SAAS,aAAa,YAAY;AAEvC,MAAI,OAAO;AACX,gBAAc;AACd,OAAK,aAAa,SAAU,GAAG;AAC7B,kBAAc,EAAE,KAAK;AACrB,WAAO;AAAA,EACT;AAEA,MAAI,aAAa,aAAa,QAAS,KAAK;AAE5C,MAAI,UAAU;AACd,MAAI,YAAY,GAAG;AACjB,cAAY,KAAK,YACb,aAAa,OAAU,WAAW,IACnC,KAAM,WAAW;AAAA,EACtB,OAAO;AACL,cAAW,cAAc,IAAG;AAAA,EAC9B;AACA,YAAW,SAAS,IAAM,UAAY,CAAC;AACvC,SAAQ,UAAU,IAAK;AACzB;AAOO,SAASC,QAAO,SAAS;AAE9B,MAAI,cAAc,IAAI,WAAW,QAAQ,MAAM;AAC/C,WAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,IAAI,KAAK,KAAK;AAClD,gBAAY,CAAC,IAAI,aAAa,QAAQ,CAAC,CAAC;AAAA,EAC1C;AACA,SAAO;AACT;AAOO,SAASC,QAAO,SAAS;AAE9B,MAAI,aAAa,IAAI,WAAW,QAAQ,MAAM;AAC9C,WAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,IAAI,KAAK,KAAK;AAClD,eAAW,CAAC,IAAI,aAAa,QAAQ,CAAC,CAAC;AAAA,EACzC;AACA,SAAO;AACT;;;ACvFA,IAAM,OAAO;AAKb,IAAM,OAAO;AAKb,IAAM,cAAc;AAAA,EAChB;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAC9B;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA,EAAE;AAAA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",
  "names": ["encode", "decode", "encode", "decode", "encodeSample", "decodeSample", "encode", "decode", "pack", "unpack", "unpack", "unpack", "pack", "unpack", "encode", "decode"]
}
